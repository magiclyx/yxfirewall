#!/bin/bash

CMD=$(basename $0)

VERSION='1.0.0'

SYSCFG_PATH='/etc/sysctl.conf'
# NF_CONNTRACK_CONFIG_PATH='/etc/modprobe.d/nf_conntrack.conf'
NF_CONNTRACK_CONFIG_PATH="/etc/modprobe.d/${CMD}.conf"


# script config path
CONFIG_DIR="/var/lib/yuxi/${CMD}"
# script saved iptables's rule path
RULE_FILENAME_v4='iptables'
RULE_FILENAME_v6='ip6tables'
RULE_DIR="/etc/yuxi/${CMD}"
# script start script on systemd
SYSTEMD_INIT_PATH="/etc/systemd/system/${CMD}.service"
# script start script on init.d
INITD_SCRIPT_PATH="/etc/init.d/${CMD}"


# silent
# error
# debug
INFO_SILENT=0
INFO_FATAL=1
INFO_ERROR=4
INFO_VERBOSE=9
INFO_LEVEL=${INFO_ERROR} # default error

#CMD
IPTABLES='/usr/sbin/iptables'
IP6TABLES='/usr/sbin/ip6tables'

IPTABLES_SAVE='/usr/sbin/iptables-save'
IP6TABLES_SAVE='/usr/sbin/ip6tables-save'

IPTABLES_RESTORE='/usr/sbin/iptables-restore'
IP6TABLES_RESTORE='/usr/sbin/ip6tables-restore'

SYSCTL='/usr/sbin/sysctl'
MODPROBE='/usr/sbin/modprobe'
LSMOD='/usr/sbin/lsmod'
CHMOD='/usr/bin/chmod'
TAR='/usr/bin/tar'
RM='/usr/bin/rm'


###########################################################
# Default port
###########################################################

declare -A DEFAULT_PORT
DEFAULT_PORT=(
  [SSH]="22"
  [FTP]="20,21"
  [DNS]="53"
  [SMTP]="25,465,587"
  [DHCP]="67,68"
  [HTTP]="80"
  [POP3]="110"
  [IDENT]="113"
  [NTP]='123'
  [NET_BIOS]="135,137,138,139,445"
  [IMAP]="143"
  [SNMP]='161' # 简单网络管理协议
  [LDAP]='389' # (轻量级目录访问协议)、ILS(定位服务)
  [HTTPS]="443"
  [RSYNC]='873'
  [IMAPS]='993'
  [POP3S]="995"
  [MYSQL]="3306"
  [ORACLE]='1521,2100'
  [MONGODB]='22122'
)


####################################################################################################
# 超时相关的配置
####################################################################################################

NET_KEY_ARRAY=(

  #该参数决定了，网络设备接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目
  net.core.netdev_max_backlog

  #该参数指定了每个套接字所允许的最大缓冲区的大小
  net.core.optmem_max

  #指定了接收套接字缓冲区大小的缺省值（以字节为单位）。
  net.core.rmem_default

  #指定了接收套接字缓冲区大小的最大值（以字节为单位)
  net.core.rmem_max

  #Linux kernel参数，表示socket监听的backlog(监听队列)上限
  net.core.somaxconn

  #定义默认的发送窗口大小；对于更大的 BDP 来说，这个大小也应该更大
  net.core.wmem_default

  #定义发送窗口的最大大小；对于更大的 BDP 来说，这个大小也应该更大
  net.core.wmem_max

  #严谨模式 1
  #松散模式 0
  net.ipv4.conf.all.rp_filter
  net.ipv4.conf.default.rp_filter

  #默认推荐设置是 htcp
  net.ipv4.tcp_congestion_control

  #关闭tcp_window_scaling
  #启用 RFC 1323 定义的 window scaling；要支持超过 64KB 的窗口，必须启用该值。
  net.ipv4.tcp_window_scaling

  #把TCP的直接拥塞通告(tcp_ecn)关掉
  net.ipv4.tcp_ecn

  #关闭tcp_sack
  #启用有选择的应答（Selective Acknowledgment），
  #这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）；
  #（对于广域网通信来说）这个选项应该启用，但是这会增加对 CPU 的占用。
  net.ipv4.tcp_sack

  #表示系统同时保持TIME_WAIT套接字的最大数量
  net.ipv4.tcp_max_tw_buckets

  #表示SYN队列长度，默认1024，改成8192，可以容纳更多等待连接的网络连接数
  net.ipv4.tcp_max_syn_backlog

  #表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
  net.ipv4.tcp_syncookies

  #开启TCP时间戳
  #以一种比重发超时更精确的方法（请参阅 RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。
  net.ipv4.tcp_timestamps

  #表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭，我推荐开启；
  net.ipv4.tcp_tw_reuse

  #表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
  net.ipv4.tcp_tw_recycle

  #表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。
  net.ipv4.tcp_fin_timeout

  #表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为30分钟，我推荐60秒。
  net.ipv4.tcp_keepalive_time

  #如果对方不予应答，探测包的发送次数
  net.ipv4.tcp_keepalive_probes

  #keepalive探测包的发送间隔
  net.ipv4.tcp_keepalive_intvl

  #确定 TCP 栈应该如何反映内存使用；每个值的单位都是内存页（通常是 4KB）。
  #第一个值是内存使用的下限。
  #第二个值是内存压力模式开始对缓冲区使用应用压力的上限。
  #第三个值是内存上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。对于较大的 BDP 可以增大这些值（但是要记住，其单位是内存页，而不是字节）。
  net.ipv4.tcp_mem

  #与 tcp_wmem 类似，不过它表示的是为自动调优所使用的接收缓冲区的值。
  net.ipv4.tcp_rmem

  #为自动调优定义每个 socket 使用的内存。
  #第一个值是为 socket 的发送缓冲区分配的最少字节数。
  #第二个值是默认值（该值会被 wmem_default 覆盖），缓冲区在系统负载不重的情况下可以增长到这个值。
  #第三个值是发送缓冲区空间的最大字节数（该值会被 wmem_max 覆盖）。
  net.ipv4.tcp_wmem

  #表示用于向外连接的端口范围。缺省情况下很小：32768到61000
  net.ipv4.ip_local_port_range

  #设置系统对最大跟踪的TCP连接数的限制
  net.ipv4.netfilter.ip_conntrack_max

  #关闭tcp的连接传输的慢启动，即先休止一段时间，再初始化拥塞窗口。
  net.ipv4.tcp_slow_start_after_idle

  #路由缓存刷新频率，当一个路由失败后多长时间跳到另一个路由，默认是300。
  net.ipv4.route.gc_timeout

  #在内核放弃建立连接之前发送SYN包的数量。
  net.ipv4.tcp_syn_retries
  #在内核放弃建立连接之前发送SYN-ACK包的数量。
  net.ipv4.tcp_synack_retries

  # 避免放大攻击
  net.ipv4.icmp_echo_ignore_broadcasts

  # 开启恶意icmp错误消息保护
  net.ipv4.icmp_ignore_bogus_error_responses

  #防止不正确的udp包的攻击
  net.inet.udp.checksum

  #是否接受含有源路由信息的ip包。参数值为布尔值，1表示接受，0表示不接受。
  #在充当网关的linux主机上缺省值为1，在一般的linux主机上缺省值为0。
  #从安全性角度出发，建议你关闭该功能。
  net.ipv4.conf.default.accept_source_route

  #echo "IP forwarding has been set to '1'"
  net.ipv4.ip_forward

  net.nf_conntrack_max
)


NETFILTER_KEY_ARRAY=(

  net.netfilter.nf_conntrack_acct  
  net.netfilter.nf_conntrack_buckets
  net.netfilter.nf_conntrack_checksum
  net.netfilter.nf_conntrack_count
  net.netfilter.nf_conntrack_events
  net.netfilter.nf_conntrack_events_retry_timeout
  net.netfilter.nf_conntrack_expect_max
  net.netfilter.nf_conntrack_frag6_high_thresh
  net.netfilter.nf_conntrack_frag6_timeout

  # 值类型：INTEGER (seconds) 
  # default 600 
  # 通用超时的默认值。 这指的是第4层未知/不支持的协议。
  net.netfilter.nf_conntrack_generic_timeout

  net.netfilter.nf_conntrack_helper

  # ICMP 默认超时时间
  # 值类型：INTEGER (seconds) 
  # default 30 
  net.netfilter.nf_conntrack_icmp_timeout
  net.netfilter.nf_conntrack_icmpv6_timeout

  net.netfilter.nf_conntrack_log_invalid

  # 一般默认 CONNTRACK_MAX 不会低于 128
  # 一般大于1GB的系统，CONTRACT_MAX 默认值是 65536
  # 而内存大于2GB时, yx_estimate_conntrack_max 才会计算出大于65536的值
  net.netfilter.nf_conntrack_max

  net.netfilter.nf_conntrack_tcp_be_liberal
  net.netfilter.nf_conntrack_tcp_loose
  net.netfilter.nf_conntrack_tcp_max_retrans

  # 值类型：INTEGER (seconds) 
  # default 10
  net.netfilter.nf_conntrack_tcp_timeout_close

  # CLOSE_WAIT是被动方收到FIN发ACK，然后会转到LAST_ACK发FIN，除非程序写得有问题，正常来说这状态持续时间很短。#默认 60 秒
  # CLOSE_WAIT 状态是让被动关闭方把该传的数据传完。如果程序写得不好，这里抛了未捕捉的异常，也许就走不到发 FIN 那步了，一直停在这里。
  net.netfilter.nf_conntrack_tcp_timeout_close_wait

  # 这个值对应的场景是 “双方建立了连接后一直不发包，直到 5天(432000秒)后才发”
  # established_time(默认 432000秒 5天), 理论上不用这么长，不小于 net.ipv4.tcp_keepalive_time 就行了。
  # 默认 keep-alive 超时时间只有 2 小时 11 分（`net.ipv4.tcp_keepalive_time + net.ipv4.tcp_keepalive_intvl * net.ipv4.tcp_keepalive_probes`）
  # 空连接攻击的最佳目标。攻击者把 IP 包头的源地址改成随机 IP，握完手就关 socket，用一台机发请求就能把你的哈希表填满
  net.netfilter.nf_conntrack_tcp_timeout_established

  #主动方的最后1个状态。默认120秒
  # default 120
  net.netfilter.nf_conntrack_tcp_timeout_fin_wait

  # 被动关闭方发 FIN 后如果一直收不到对面的 ACK 或 RST，会不断重发，
  # 直到超时才 CLOSE。`net.ipv4.tcp_retries2` 的默认值是 15，最多要等 924.6 秒……不过一般都会调小这个值。
  # 值类型：INTEGER (seconds) 
  # default 30
  net.netfilter.nf_conntrack_tcp_timeout_last_ack

  # 值类型：INTEGER (seconds) 
  # default 300
  net.netfilter.nf_conntrack_tcp_timeout_max_retrans

  # 类似，故意不发握手的 ACK 即可。但这个超时时间没那么夸张，系统也有 syn cookie 机制来缓解 syn flood 攻击。
  # 值类型：INTEGER (seconds) 
  # default 60
  net.netfilter.nf_conntrack_tcp_timeout_syn_recv

  # 值类型：INTEGER (seconds) 
  # default 120
  net.netfilter.nf_conntrack_tcp_timeout_syn_sent

  # - Linux 里的 MSL 写死 60 秒（而不是 TCP 标准里拍脑袋的 120 秒），TIME_WAIT 要等 2MSL，这里 120 算是个合理的值。
  # - 但现在默认有 PAWS（`net.ipv4.tcp_timestamps`），不会出现标准制定时担心的迷途报文回来碰巧污染了序列号相同的新连接的数据的情况
  # 互联网公司基本都开 `net.ipv4.tcp_tw_reuse`，既然半连接都不留这么久，记录似乎也不需要留这么久。
  net.netfilter.nf_conntrack_tcp_timeout_time_wait

  # 值类型：INTEGER (seconds) 
  # default 300
  net.netfilter.nf_conntrack_tcp_timeout_unacknowledged

  net.netfilter.nf_conntrack_timestamp

  # 值类型：INTEGER (seconds) 
  # default 30
  net.netfilter.nf_conntrack_udp_timeout

  # 值类型：INTEGER (seconds) 
  # default 180 
  # 如果检测到UDP流，将使用此扩展超时.
  net.netfilter.nf_conntrack_udp_timeout_stream
)

NETFILTER_MOD_CONFIG_KEY_ARRAY=(
  options#nf_conntrack#hashsize
)

# Ubuntu 16.04
# net.netfilter.nf_conntrack_generic_timeout = 600
# net.netfilter.nf_conntrack_icmp_timeout = 30
# net.netfilter.nf_conntrack_tcp_timeout_close = 10
# net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60
# net.netfilter.nf_conntrack_tcp_timeout_established = 432000
# net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120
# net.netfilter.nf_conntrack_tcp_timeout_last_ack = 30
# net.netfilter.nf_conntrack_tcp_timeout_max_retrans = 300
# net.netfilter.nf_conntrack_tcp_timeout_syn_recv = 60
# net.netfilter.nf_conntrack_tcp_timeout_syn_sent = 120
# net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120
# net.netfilter.nf_conntrack_tcp_timeout_unacknowledged = 300
# net.netfilter.nf_conntrack_udp_timeout = 30
# net.netfilter.nf_conntrack_udp_timeout_stream = 180


# centos 7.8
# net.netfilter.nf_conntrack_dccp_timeout_closereq = 64
# net.netfilter.nf_conntrack_dccp_timeout_closing = 64
# net.netfilter.nf_conntrack_dccp_timeout_open = 43200
# net.netfilter.nf_conntrack_dccp_timeout_partopen = 480
# net.netfilter.nf_conntrack_dccp_timeout_request = 240
# net.netfilter.nf_conntrack_dccp_timeout_respond = 480
# net.netfilter.nf_conntrack_dccp_timeout_timewait = 240
# net.netfilter.nf_conntrack_events_retry_timeout = 15
# net.netfilter.nf_conntrack_generic_timeout = 600
# net.netfilter.nf_conntrack_icmp_timeout = 30
# net.netfilter.nf_conntrack_sctp_timeout_closed = 10
# net.netfilter.nf_conntrack_sctp_timeout_cookie_echoed = 3
# net.netfilter.nf_conntrack_sctp_timeout_cookie_wait = 3
# net.netfilter.nf_conntrack_sctp_timeout_established = 432000
# net.netfilter.nf_conntrack_sctp_timeout_heartbeat_acked = 210
# net.netfilter.nf_conntrack_sctp_timeout_heartbeat_sent = 30
# net.netfilter.nf_conntrack_sctp_timeout_shutdown_ack_sent = 3
# net.netfilter.nf_conntrack_sctp_timeout_shutdown_recd = 0
# net.netfilter.nf_conntrack_sctp_timeout_shutdown_sent = 0
# net.netfilter.nf_conntrack_tcp_timeout_close = 10
# net.netfilter.nf_conntrack_tcp_timeout_close_wait = 3600
# net.netfilter.nf_conntrack_tcp_timeout_established = 86400
# net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120
# net.netfilter.nf_conntrack_tcp_timeout_last_ack = 30
# net.netfilter.nf_conntrack_tcp_timeout_max_retrans = 300
# net.netfilter.nf_conntrack_tcp_timeout_syn_recv = 60
# net.netfilter.nf_conntrack_tcp_timeout_syn_sent = 120
# net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120
# net.netfilter.nf_conntrack_tcp_timeout_unacknowledged = 300
# net.netfilter.nf_conntrack_udp_timeout = 30
# net.netfilter.nf_conntrack_udp_timeout_stream = 180


####################################################################################################
# OS
####################################################################################################

function os_type()
{
	
	local release=''
	
	if [ -n "${OSTYPE}" ]; then
		if [[ "${OSTYPE}" == "linux-gnu"* ]]; then
			release="linux"
		elif [[ "${OSTYPE}" == "bsd"* ]]; then 
			release="bsd"
		elif [[ "${OSTYPE}" == "freebsd"* ]]; then 
			release="freebsd"
		elif [[ "${OSTYPE}" == "darwin"* ]]; then 
			release="osx"
		elif [[ "${OSTYPE}" == "solaris"* ]]; then 
			release="solaris"
		elif [[ "${OSTYPE}" == "cygwin" ]]; then 
			# POSIX compatibility layer and Linux environment emulation for Windows 
			release="cygwin"
		elif [[ "${OSTYPE}" == "msys" ]]; then 
			# Lightweight shell and GNU utilities compiled for Windows (part of MinGW) 
			release="msys"
		elif [[ "${OSTYPE}" == "win32" ]]; then 
			# I'm not sure this can happen. 
			release="windows"
		else 
			release="unknown"
		fi
	else
		
		# $OSTAYPE not recognized by the older shells (such as Bourne shell).
		# Use `uname` instead
		
		case $(uname | tr '[:upper:]' '[:lower:]') in
			linux*)
				release='linux'
			;;
			freebsd*)
				release='freebsd'
			;;
			darwin*)
				release="osx"
			;;
			SunOS*)
				release="solaris"
			;;
			msys*)
				release="msys"
			;;
			windows*)
				release="windows"
			;;
			*)
				release="unknown"
			;;
		esac
	fi
	

	echo "${release}"
}

function linux_type()
{
  if [ "$(id -u)" -ne 0 ]; then
    echo_fatal "should run with root"
  fi

  local release=
	if [[ "${OSTYPE}" == "linux-gnu"* ]]; then
		if [[ -n $(find /etc -name "redhat-release") ]] || grep </proc/version -q -i "centos"; then
			release="centos"
		elif grep </etc/issue -q -i "debian" && [[ -f "/etc/issue" ]] || grep </etc/issue -q -i "debian" && [[ -f "/proc/version" ]]; then
			release="debian"
		elif grep </etc/issue -q -i "ubuntu" && [[ -f "/etc/issue" ]] || grep </etc/issue -q -i "ubuntu" && [[ -f "/proc/version" ]]; then
			release="ubuntu"
		else
			release="linux"
		fi
	else
	    release="unknown"
	fi

  echo "${release}"
}



function yx_size_to_bytes()
{
  local memstr=$1

  local memsize=
  if [ -n "${memstr}" ]; then
    if echo "${memstr}" | grep -Eqi "^[[:space:]]*[1-9]+[0-9]*[[:space:]]*(GB|G)[[:space:]]*$"; then
      local num=$(echo "${memstr}" | grep -Eo '[1-9]+[0-9]*')
      ((memsize=num*1024*1024*1024))
    elif echo "${memstr}" | grep -Eqi "^[[:space:]]*[1-9]+[0-9]*[[:space:]]*(MB|M)[[:space:]]*$"; then
      local num=$(echo "${memstr}" | grep -Eo '[1-9]+[0-9]*')
      ((memsize=num*1024*1024))
    elif echo "${memstr}" | grep -Eqi "^[[:space:]]*[1-9]+[0-9]*[[:space:]]*(KB|K)[[:space:]]*$"; then
      local num=$(echo "${memstr}" | grep -Eo '[1-9]+[0-9]*')
      ((memsize=num*1024))
    elif echo "${memstr}" | grep -Eqi "^[[:space:]]*[1-9]+[0-9]*[[:space:]]*(B|BYTE)?[[:space:]]*$"; then
      memsize=$(echo "${memstr}" | grep -Eo '[1-9]+[0-9]*')
    fi


    if [[ -n "${memsize}" ]] && [[ ${memsize}=~^[1-9]+[0-9]*$ ]]; then
      echo "${memsize}"
      return 0
    else
      return 1
    fi
    
  fi
}


function yx_estimate_conntrack_max()
{
  
  # memory size in bytes
  local memsize=$(yx_size_to_bytes "${1}")

  if [[ -n "${memsize}" ]] && [[ ${memsize}=~^[1-9]+[0-9]*$ ]]; then
  # if _valid_memsize "${memsize}"; then
    local arch=
    if [[ $(uname -m)=='x86_64' ]]; then
      arch=64
    else
      arch=32
    fi
    
    if [[ -n "${memsize}" ]] && [[ -n "${arch}" ]]; then
      # CONNTRACK_MAX=RAMSIZE / 16384 / (ARCH/32)
      local arch_params=$((arch/32))
      local conntrack_max=$((memsize/16384/arch_params))
      if [ ${conntrack_max} -lt 128 ]; then
        # 一般默认 CONNTRACK_MAX 不会低于 128
        conntrack_max=128
      fi
      
      echo "${conntrack_max}"
      return 0
    fi
  fi
  
  return 1
}


function yx_mem_total()
{
  function _valid_memsize()
  {
    local memsize=$1
    
    if [[ -n "${memsize}" ]] && [[ ${memsize}=~^[1-9]+[0-9]*$ ]]; then
      return 0
    else
      return 1
    fi
  }

  local memsize=

  if [[ $(os_type) == 'osx' ]]; then
    local mem_mb=$(top -l 1 | head -n 10 | grep PhysMem | awk '{print $2}')
    memsize=$(yx_size_to_bytes "${mem_mb}")
  else
      if ! _valid_memsize "${memsize}"; then
      local mem_kb=
      if which free > /dev/null; then
        mem_kb=$(free | grep -i "mem" | awk '{print $2}')
        ((memsize=mem_kb*1024))
      fi
    fi
    
    if ! _valid_memsize "${memsize}"; then
      if [ -f /proc/meminfo ]; then
        mem_kb=$(cat /proc/meminfo | head -n 1 | awk '{print $2}')
        ((memsize=mem_kb*1024))
      fi
    fi
  fi

  if _valid_memsize "${memsize}"; then
    echo "${memsize}"
    return 0
  else
    return 1
  fi
}

####################################################################################################
# configuration
####################################################################################################

function _sed_escape() {
  sed -e 's/[][\/^$?*.]/\\&/g'
}

function _grep_escape() {
  sed -e 's/[][\/^$?+*.]/\\&/g' 
}


function yx_has_config()
{

	local file=
	local key=

	while [ $# -gt 0 ]; do
		case $1 in
		--file )
			shift
			file=$1
		;;

		--key )
			shift
			key=$1
		;;

		*)
			echo_fatal "Invalid optional ${1}"
		;;
		esac
		shift
	done


	if [ -z "${key}" ]; then
		echo_fatal 'key is empty'
	fi

	if [ -z "${file}" ]; then
		echo_fatal 'file is empty'
	fi

	
	local fixkey=$(echo "${key}" | _grep_escape)
	test -f "${file}" && grep -Eq "^\s*${fixkey}\s*=\s*.*$" "${file}" 
}

function yx_read_config()
{

	local file=
	local key=

	while [ $# -gt 0 ]; do
		case $1 in
		--file )
			shift
			file=$1
		;;

		--key )
			shift
			key=$1
		;;

		*)
			echo_fatal "Invalid optional ${1}"
		;;
		esac
		shift
	done

	if [ -z "${key}" ]; then
		echo_fatal 'key is empty'
	fi

	if [ -z "${file}" ]; then
		echo_fatal 'file is empty'
	fi


	local sed_fixkey=$(echo "${key}" | _sed_escape)
	local grep_fixkey=$(echo "${key}" | _grep_escape)
	test -f "${file}" && grep -E "^\s*${grep_fixkey}\s*=\s*" "${file}" | sed -e  "s/[[:space:]]*${sed_fixkey}[[:space:]]*=[[:space:]]*//g" | grep -o "[^ ]\+\( \+[^ ]\+\)*"
}

function yx_delete_config()
{

	local file=
	local key=

	while [ $# -gt 0 ]; do
		case $1 in
		--file )
			shift
			file=$1
		;;

		--key )
			shift
			key=$1
		;;

		*)
			echo_fatal "Invalid optional ${1}"
		;;
		esac
		shift
	done


	if [ -z "${key}" ]; then
		echo_fatal 'key is empty'
	fi

	if [ -z "${file}" ]; then
		echo_fatal 'file is empty'
	fi


	local fixkey=$(echo "${key}" | _sed_escape)
	if [[ $(os_type) == 'osx' ]]; then
		test -f "${file}" && sed -i "" "/^[[:space:]]*${fixkey}[[:space:]]*=.*$/d" "${file}"
	else
		test -f "${file}" && sed -i "/^[[:space:]]*${fixkey}[[:space:]]*=.*$/d" "${file}"
	fi
}

function yx_commentout_config()
{
    
	local file=
	local key=

	while [ $# -gt 0 ]; do
		case $1 in
		--file )
			shift
			file=$1
		;;

		--key )
			shift
			key=$1
		;;

		*)
			echo_fatal "Invalid optional ${1}"
		;;
		esac
		shift
	done


	if [ -z "${key}" ]; then
		echo_fatal 'key is empty'
	fi

	if [ -z "${file}" ]; then
		echo_fatal 'file is empty'
	fi

	
	local fixkey=$(echo "${key}" | _sed_escape)
	if [[ $(os_type) == 'osx' ]]; then
		test -f "${file}" && sed -i "" "s/^[[:space:]]*\(${fixkey}[[:space:]]*=.*\)$/#\1/g" "${file}"
	else
		test -f "${file}" && sed -i "s/^[[:space:]]*\(${fixkey}[[:space:]]*=.*\)$/#\1/g" "${file}"
	fi
}

function yx_write_config()
{

	local file=
	local key=
	local val=
  local space=' '
  local nospace=false
  local duplicate=false

	while [ $# -gt 0 ]; do
		case $1 in
		--file )
			shift
			file=$1
    ;;

		--key )
			shift
			key=$1
    ;;

		--val )
			shift
			val=$1
    ;;

		--no-space )
      # A = B 还是 A=B
      # 如果部分配置文件，不允许等号两旁优空格
      # 使用 --no-space
			nospace=true
    ;;

    --duplicate-key )
      # Key 是否可以重复。
      # 如果当存在 A = 2 时， 写入 A = 3
      # 默认行为是将 A = 2 替换为 A = 3
      # 当使用 --dupliate-key 参数时 
      # 会在 A = 2 下面 添加 A = 3.
			duplicate=true
    ;;


    *)
			echo_fatal "Invalid optional ${1}"
    ;;
		esac
		shift
	done


  if [ -z "${key}" ]; then
    echo_fatal 'key is empty'
	fi

	if [ -z "${val}" ]; then
    echo_fatal 'val is empty'
	fi

	if [ -z "${file}" ]; then
		echo_fatal 'file is empty'
	fi

  # 部分配置文件，不允许等号两旁有空格
  if ${nospace}; then
    space=''
  fi


	local sed_fixkey=$(echo "${key}" | _sed_escape)
	local grep_fixkey=$(echo "${key}" | _grep_escape)
	if test -f "${file}" &&  grep -Eq "^\s*${grep_fixkey}\s*=\s*${val}\s*$" "${file}"; then # Testfile exist and text 'key = val' exist, do nothing ...
		:
	elif test -f "${file}" && grep -Eq "^\s*#\s*${grep_fixkey}\s*=.*$" "${file}"; then #Test file exist and text '# key = xxx' exist
		if 	grep -Eq "^\s*#\s*${grep_fixkey}\s*=\s*${val}\s*$" "${file}"; then #Test exist '# key = val', remove '#' and format line.
			if [[ $(os_type) == 'osx' ]]; then
				sed -i "" "s/^[[:space:]]*#*[[:space:]]*${sed_fixkey}[[:space:]]*=.*/${sed_fixkey}${space}=${space}${val}/g" "${file}"
			else
				sed -i "s/^[[:space:]]*#*[[:space:]]*${sed_fixkey}[[:space:]]*=.*/${sed_fixkey}${space}=${space}${val}/g" "${file}"
			fi
		else # Text '# key=???' exist, append 'key = val' below.
			if [[ $(os_type) == 'osx' ]]; then
			    # 因为sed在OSX上的问题，这里不得不换行!!!
				sed -i "" "/^[[:space:]]*#*[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a\\
				${sed_fixkey} = ${val}\\
				" "${file}"
			else
				sed -i "/^[[:space:]]*#*[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a ${sed_fixkey}${space}=${space}${val}" "${file}"
			fi
		fi
  elif test -f "${file}" && grep -Eq "^\s*${grep_fixkey}\s*=.*$" "${file}"; then #Test file exist and text 'key = xxx' exist
    if ${duplicate}; then
      if [[ $(os_type) == 'osx' ]]; then
			    # 因为sed在OSX上的问题，这里不得不换行!!!
				sed -i "" "/^[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a\\
				${sed_fixkey} = ${val}\\
				" "${file}"
			else
				sed -i "/^[[:space:]]*${sed_fixkey}[[:space:]]*=.*/ a ${sed_fixkey}${space}=${space}${val}" "${file}"
			fi
    else
      if [[ $(os_type) == 'osx' ]]; then
        sed -i "" "s/^[[:space:]]*${sed_fixkey}[[:space:]]*=.*/${sed_fixkey}${space}=${space}${val}/g" "${file}"
		  else
        sed -i "s/^[[:space:]]*${sed_fixkey}[[:space:]]*=.*/${sed_fixkey}${space}=${space}${val}/g" "${file}"
      fi
    fi
	else
		echo "${key}${space}=${space}${val}" >> "${file}"
	fi	
}

function yx_allkeys_config()
{
	
	local file=
	
	while [ $# -gt 0 ]; do
		case $1 in
			--file )
				shift
				file=$1
			;;
			
			*)
				echo_fatal "Invalid optional ${1}"
			;;
		esac
		shift
	done
	
	
	if [ -z "${file}" ]; then
		echo_fatal 'file is empty'
	fi
	
	if [ -f "${file}" ]; then
		while read line; do
			echo ${line} | sed -e "s/^[[:space:]]*\(.*\)[[:space:]]*=.*$/\1/g" | grep -o "[^ ]\+\( \+[^ ]\+\)*"
		done < "${file}"
	fi
	
}

####################################################################################################
# Other sysctl operation
####################################################################################################
function yx_sysctl_config()
{
  local file=
	local key=
	local val=
  local refresh=false

  local option=

	while [ $# -gt 0 ]; do
		case $1 in

    --read )
      option='READ'
    ;;

    --write )
      option='WRITE'
    ;;

    --remove )
      option='REMOVE'
    ;;

    --exist )
      option='EXIST'
    ;;

    --all-keys )
      option='ALL-KEYS'
    ;;

		--file )
			shift
			file=$1
    ;;

		--key )
			shift
			key=$1
    ;;

		--val )
			shift
			val=$1
    ;;

    --refresh )
			refresh=true
    ;;

    *)
			echo_fatal "Invalid optional ${1}"
    ;;
		esac
		shift
	done


  function _refresh_sysctl_config()
  {
    #:echo_cmd
    echo_verbose 'Make system configure enable...'
    echo_verbose "${SYSCTL} -p ${file} > /dev/null"
    "${SYSCTL}" -p "${file}" > /dev/null
  }


  if [ -z "${file}" ]; then
    file="${SYSCFG_PATH}"
  fi


  if [[ "${option}" == 'READ' ]]; then

    if [ -z "${key}" ]; then
      echo_fatal "Empty key on sysctl config key."
    fi

    yx_read_config --file "${file}" --key "${key}"
  elif [[ "${option}" == 'WRITE' ]]; then

    if [ -z "${key}" ]; then
      echo_fatal "Empty value on sysctl config key."
    fi

    if [ -z "${val}" ]; then
      echo_fatal "Empty value on sysctl config val."
    fi

    # write config
    echo_verbose "Set sysctl config: ${key} = ${val}"
    yx_write_config --file "${file}" --key "${key}" --val "${val}"

    #如果需要，立即应用更改
    if ${refresh}; then
      _refresh_sysctl_config
    fi

    # verify
    local test_val=$(yx_read_config --file "${file}" --key "${key}")
    if [[ -n "${test_val}" ]] && [[ "${test_val}" == "${val}" ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${option}" == 'REMOVE' ]]; then
      if [ -z "${key}" ]; then
        echo_fatal "Empty value on sysctl config key."
      fi

      echo_verbose "Remove sysctl config with key: ${key}"
      yx_delete_config --file "${file}" --key "${key}"
      return $?

  elif [[ "${option}" == 'EXIST' ]]; then
    if [ -z "${key}" ]; then
      echo_fatal "Empty value on sysctl config key."
    fi
    yx_has_config --file "${file}" --key "${key}"
    return $?
  elif [[ "${option}" == 'ALL-KEYS' ]]; then
    yx_allkeys_config --file "${file}"
  else
    if ${refresh}; then
      _refresh_sysctl_config
    fi
  fi

}


function yx_modprobe_config()
{
  local file=
	local key=
	local val=
  local refresh=false

  local option=

	while [ $# -gt 0 ]; do
		case $1 in

		--file )
			shift
			file=$1
    ;;

    --read )
      option='READ'
    ;;

    --write )
      option='WRITE'
    ;;

    --exist )
      option='EXIST'
    ;;

    --remove )
      option='REMOVE'
    ;;

    --all-keys )
      option='ALL-KEYS'
    ;;

		--key )
			shift
			key=$1
    ;;

		--val )
			shift
			val=$1
    ;;

    --refresh )
			refresh=true
    ;;

    *)
			echo_fatal "Invalid optional ${1}"
    ;;
		esac
		shift
	done

  if [ -z "${file}" ]; then
    file="${NF_CONNTRACK_CONFIG_PATH}"
  fi

  if [[ "${option}" == 'READ' ]]; then
    if [ -z "${key}" ]; then
      echo_fatal "Empty value on modprobe config key."
    fi
    yx_read_config --file "${file}" --key "${key}"
  elif [[ "${option}" == 'WRITE' ]]; then

    if [ -z "${key}" ]; then
      echo_fatal "Empty value on modprobe config key."
    fi

    if [ -z "${val}" ]; then
      echo_fatal "Empty value on modprobe config val."
    fi

    # write config
    echo_verbose "Set iptables config: ${key} = ${val} ..."
    yx_write_config --no-space --file "${file}" --key "${key}" --val "${val}"


    #如果需要，立即应用更改
    if ${refresh}; then
      local model_name=$(echo "${key}" | awk '{print $2}')
      local parameters=$(echo "${key}" | awk '{print $3}')
      if [[ -z "${model_name}" ]] || [[ -z "${parameters}" ]]; then
        echo_fatal "Fail to parse config key:${key}"
      fi

      if ! ${LSMOD} | grep -qi "${model_name}"; then
        echo_err "${model_name} module not loaded, try force load it"
        echo_cmd "${MODPROBE} ${model_name}"
        if [[ $? != '0' ]]; then
          echo_fatal "Failed to load the module ${model_name}"
        fi
      fi

      echo_verbose 'Make iptables configure enable...'
      echo "${val}" > "/sys/module/${model_name}/parameters/${parameters}"

    fi

    # verify
    local test_val=$(yx_read_config --file "${file}" --key "${key}")
    if [[ -n "${test_val}" ]] && [[ "${test_val}" == "${val}" ]]; then
      return 0
    else
      return 1
    fi
  elif [[ "${option}" == 'REMOVE' ]]; then
      if [ -z "${key}" ]; then
        echo_fatal "Empty value on modprobe config key."
      fi

      echo_verbose "Remove modprobe config with key: ${key}"
      yx_delete_config --file "${file}" --key "${key}"
      return $?

  elif [[ "${option}" == 'EXIST' ]]; then
    if [ -z "${key}" ]; then
      echo_fatal "Empty value on modprobe config key."
    fi
    yx_has_config --file "${file}" --key "${key}"
    return $?
  elif [[ "${option}" == 'ALL-KEYS' ]]; then
    yx_allkeys_config --file "${file}"
  else
    if ${refresh}; then
      # iptables 配置文件，不能够直接refresh !!
      echo_fatal "refresh iptables config need a specific key-val items."
    fi
  fi

}

####################################################################################################
# Other YXLib
####################################################################################################


function yx_str_checkfmt()
{
	local reg=$1
	local str=$2
	
	if [[ -z ${str} ]]; then
		str=''
	fi
	
	if [[ -z ${reg} ]]; then
		reg='^\s*[^\s]+\s*$'
	fi
	
	if ! [[ ${str} =~ ${reg} ]] ; then
		return 1
	fi
	
	return 0
}

# function ip_forward_v4()
# {
#   local option=$1
#   shift
#   if [ -z ${option} ]; then
#     echo_fatal 'iptables_default need at least one params [DROP , ACCEPT]'
#   else
#     if strcontains "${option}" 'Enable Accept Allow 1' --ignorecase; then
#       option='1'
#     else
#       option='0'
#     fi
#   fi

#   # 使用sed更改sysctl.conf中的ip_forward值
#   #:echo_cmd
#   echo_verbose 'Set ipv4.ip_forward = 1 ...'
#   echo_verbose "sed -i \"s/^#\? *net.ipv4.ip_forward.*/net.ipv4.ip_forward = ${option}/g\" \"${SYSCFG_PATH}\""
#   sed -i "s/^#\? *net.ipv4.ip_forward.*/net.ipv4.ip_forward = ${option}/g" "${SYSCFG_PATH}"
 
#   #如果需要，立即应用更改
#   #:echo_cmd
#   echo_verbose 'Make system configure enable...'
#   echo_verbose "${SYSCTL} -p > /dev/null"
#   "${SYSCTL}" -p > /dev/null

#   local result=0
#   if grep -Eq "^ *net.ipv4.ip_forward" "${SYSCFG_PATH}"; then
#     result=$(grep -E "^ *net.ipv4.ip_forward" "${SYSCFG_PATH}" | sed -e 's/^[^#=]*= *//g' )
#   else
#     result=0
#   fi

#   if [[ ${result} == 1 ]]; then
#     return 0
#   else
#     return 1
#   fi
# }

function ip_from_inter()
{
	local inter=
	if (( $# == 0 )) ; then
		read -r -t 5 -d $'\0' inter
#		num=`cat < /dev/stdin`
	else
		inter="$*"
	fi

  if [ -z "${inter}" ]; then
    echo_fatal "inter is empty"
  fi

  local Local_Address=
  if which ip > /dev/null; then
  # try using `ip` command
      Local_Address=$(ip addr show ${inter} | grep -w inet | awk '{print $2}')
  else
  # Some old platform, still using `ifconfig` command
      Local_Address=$(ifconfig ${inter} | grep -w inet | awk '{print $2}')
      if [ -n "${Local_Address}" ]; then
          local lmask=$(ifconfig ${inter} | grep -w netmask | awk '{print $4}' | tr '[:lower:]' '[:upper:]' | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          local bitnum=0
          if [[ "${lmask}" =~ ^0X[0-9A-F]{8}$ ]]; then
          # in most linux platform, mask is a string split by '.'(255.255.255.0)
              bitnum=$(echo "obase=2;ibase=16;${lmask:2}" | bc | grep -o '1' | wc -l | grep -o "[^ ]\+\( \+[^ ]\+\)*")
          elif [[ "${lmask}" =~ ^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}(/[0-3]?[0-9])?$ ]]; then
          # in OSX and some platform, mask is a hex number with '0x' prefix
              mask_array=
              IFS='.' read -r -a mask_array <<< "${lmask}"

              for octet in "${mask_array[@]}"; do
                  ((bitnum = bitnum + "$(echo "obase=2;ibase=10;${octet}"| bc | grep -o '1' | wc -l | grep -o "[^ ]\+\( \+[^ ]\+\)*")"))
              done
          fi

          if [[ -n ${bitnum} ]]  &&  [[ ! "${bitnum}" -eq 0 ]]; then
              Local_Address="${Local_Address}/${bitnum}"
          fi

      fi
  fi

  echo "${Local_Address}"
}

function show_wellknown_port()
{
  local times=0
  for protocol in ${!DEFAULT_PORT[@]}; 
  do
    (( times=times+1 ))
    printf "%8s:%-20s    " ${protocol} ${DEFAULT_PORT[${protocol}]}

    if [ "${times}" -eq 4 ]; then
      echo ""
      (( times=0 ))
    fi

  done
}

function strcontains()
{
	local str="$1"
	local arr_str="$2"
	local ignorecase=false
	shift 
	shift 
	
	while [ $# -gt 0 ]; do
		case $1 in
			
			--ignorecase )
				ignorecase=true
			;;
			
			*)
				echo "Invalid optional ${1}"
			;;
		esac
		shift
	done

	
	if ${ignorecase}; then
		for e in $(echo "${arr_str}"); do
			[[ "${e^^}" == "${str^^}" ]] && return 0
		done
	else
		for e in $(echo "${arr_str}"); do
      echo "compare between ${e} and ${str}"
			[[ "${e}" == "${str}" ]] && return 0
		done
	fi
	
	return 1
}

function fixstr()
{
	local str="$1"
	local arr_str="$2"
	shift
	shift
	
	local fixstr=''
	for element in $(echo ${arr_str:2}); do
		if [[ "${element^^}" == "${str^^}" ]]; then
			fixstr="${element}"
			break
		fi
	done
	
	echo "${fixstr}"
}


####################################################################################################
# Handler
####################################################################################################
declare -A PROTOCOL_HANDLER_MAP
PROTOCOL_HANDLER_MAP=()


function encode_handler() {
	local -n dict_ref=$1
	local str=""
	for key in "${!dict_ref[@]}"; do
		str+="${key}=${dict_ref[$key]},"
	done
	echo "${str%,}" # 移除最后一个逗号
}


function decode_handler() {
	local str=$1
	local -n dict_ref=$2
	local entry
	while read -r entry; do
		local key=${entry%%=*}
		local value=${entry#*=}
		dict_ref[$key]=$value
	done <<< "$(echo "$str" | tr ',' '\n')"
}


function regist_handler()
{
	if [ -n ${1} ] && [ -n ${2} ]; then
	  PROTOCOL_HANDLER_MAP[${1^^}]=$2
	else
	  echo "${FUNCNAME} need at least two params:protocol and handler"
	  return 1
	fi
}

function unregist_handler()
{
	if [ -n "${1}" ]; then
		unset PROTOCOL_HANDLER_MAP[${1^^}]
	fi
}

function has_handler()
{
	if [ -n $1 ]; then
		if [ -v PROTOCOL_HANDLER_MAP[${1^^}] ]; then
			return 0
		fi
	fi
	
	return 1
}

function search_handler()
{
	local handler_func_name=
	if [ -n $1 ]; then
		handler_func_name="${PROTOCOL_HANDLER_MAP[${1^^}]}"
		if [ -n ${handler_func_name} ]; then
			${handler_func_name}
		fi
	fi
}

function search_handler_info()
{
	local protocol=$1
	local key=$2
	local -A handler
	if [ -n "${protocol}" ] && [ -n "${key}" ]; then
		local handler_obj=$(search_handler "${protocol}")
		if [ -n "${handler_obj}" ]; then
			decode_handler "${handler_obj}" handler
			echo ${handler[${key}]}
		fi
	fi
}

function list_handler_protocol()
{
  for protocol in ${!PROTOCOL_HANDLER_MAP[@]}; 
  do
    echo ${protocol}
  done
}


####################################################################################################
# Logger
####################################################################################################

function valid_info_level()
{
  local info_level=$1

  if [ -z "${info_level}" ]; then
    return 1
  fi

  if ! strcontains "${info_level}" 'silent fatal error verbose' --ignorecase; then
    if ! yx_str_checkfmt '^([0-9])+$' "${info_level}"; then
      return 1
    fi
  fi

  return 0
}

function set_info_level()
{
  local info_level=$1
  if [ -n "${info_level}" ]; then

    if yx_str_checkfmt '^([0-9])+$' "${info_level}"; then
      INFO_LEVEL=${info_level}
    else
      if strcontains "${info_level}" 'silent' --ignorecase; then
        INFO_LEVEL=${INFO_SILENT}
      elif strcontains "${info_level}" 'fatal' --ignorecase; then
        INFO_LEVEL=${INFO_FATAL}
      elif strcontains "${info_level}" 'error' --ignorecase; then
        INFO_LEVEL=${INFO_ERROR}
      elif strcontains "${info_level}" 'verbose' --ignorecase; then
        INFO_LEVEL=${INFO_VERBOSE}
      else
        echo_fatal "Unknown info level:${info_level}"
      fi
    fi # end of 'if yx_str_checkfmt '^([0-9])+$' '

  fi # end of 'if [ -n ${info_level} ]'
}


function echo_verbose()
{
  if (( "${INFO_LEVEL}" < "${INFO_VERBOSE}" )); then
    return
  fi

  local str=
	if (( $# == 0 )) ; then
		read -r -t 5 -d $'\0' str
#		num=`cat < /dev/stdin`
	else
		str="$*"
	fi

  (>&1 echo "${str}")
}

function echo_err()
{
  if (( "${INFO_LEVEL}" < "${INFO_ERROR}" )); then
    return
  fi

  local str=
	if (( $# == 0 )) ; then
		read -r -t 5 -d $'\0' str
#		num=`cat < /dev/stdin`
	else
		str="$*"
	fi

  local magenta=$(tput setaf 5);
  local reset=$(tput sgr0);

  (>&2 echo "${magenta}${str}${reset}")
}

function echo_fatal()
{
  if (( "${INFO_LEVEL}" < "${INFO_FATAL}" )); then
    exit 1
  fi

  local str=
	if (( $# == 0 )) ; then
		read -r -t 5 -d $'\0' str
#		num=`cat < /dev/stdin`
	else
		str="$*"
	fi

  local red=$(tput setaf 1);
  local reset=$(tput sgr0);
  
  (>&2 echo "${red}Fatal:${str}${reset}");
  exit 1;
}

# Can not handle 'pipe' and 'output redirect'
# Use '#:echo_cmd' mark all not handle code place
function echo_cmd()
{
  echo_verbose "$@"
  $@
}

function analysis_cmd()
{
  echo "##############################################################################"
  echo "Run command:\"$@\""
  echo "------------------------------------------------------------------------------"
  local start=$(date +%s)
	$@
	local exit_code=$?
  echo "------------------------------------------------------------------------------"
	echo "took $(($(date +%s)-${start})) seconds. exited with ${exit_code}"
  echo "##############################################################################"
	return $exit_code
}


####################################################################################################
# limit
####################################################################################################

function _parse_limit()
{
	local limit_params=''
	
	local limit="$1"
	local burst="$2"
	
	
	if [[ -n ${burst} ]] || [[ -n ${limit} ]]; then
		
		limit_params=' -m limit'
		
		
		# --limit
		if [[ -n ${limit} ]]; then
			if yx_str_checkfmt '^([0-9])+/(s|min|second|minute|hour|day)$' "${limit}"; then
				limit_params="${limit_params} --limit ${limit}"
			else
				echo_fatl "\"${limit}\" is not a valid params for --freq"
			fi
		fi
		
		# --limit-burst
		if [[ -n ${burst} ]]; then
			if yx_str_checkfmt '^([0-9])+$' "${burst}"; then
				limit_params="${limit_params} --limit-burst ${burst}"
			else
				echo_fatal "\"${burst}\" is not a valid params for --limit"
			fi
		fi
	fi
	
	echo "${limit_params}"
}

# <above/upto>:<limit>:[burst]:[name]:[mode]:[expire]:[gc]
function _parse_limit2_old()
{
  local limitstr=$1

  local limit_params=''
  if [ -n "${limitstr}" ]; then
    local control=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $1}')
    local limit=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $2}')
    local burst=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $3}')
    local name=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $4}')
    local mode=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $5}')
    local srcmask=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $6}')
    local dstmask=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $7}')
    local expire=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $8}')
    local gc=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $9}')

    local above=
    local upto=

    if [ "${control}" == 'above' ]; then
      above="${limit}"
    elif [ "${control}" == 'upto' ]; then
      upto="${limit}"
    fi

    if [ -n "${above}" ] || [ -n "${upto}" ]; then

      if [ -z "${name}" ]; then

        if [ -n "${upto}" ]; then

          limit_params=' -m limit'

          # --limit
          if [[ -n ${upto} ]]; then
            if yx_str_checkfmt '^([0-9])+/(s|min|second|minute|hour|day)$' "${upto}"; then
              limit_params="${limit_params} --limit ${upto}"
            else
              echo_fatl "\"${upto}\" is not a valid params for above"
            fi
          fi

          # --limit-burst
          if [[ -n ${burst} ]]; then
            if yx_str_checkfmt '^([0-9])+$' "${burst}"; then
              limit_params="${limit_params} --limit-burst ${burst}"
            else
              echo_fatal "\"${burst}\" is not a valid params for --limit"
            fi
          fi

        elif [ -n "${above}" ]; then
          echo_fatal "limit optional --above need --name params"
        fi
      else

        limit_params=" -m hashlimit --hashlimit-name ${name}"

        if [ -n "${upto}" ]; then
          if yx_str_checkfmt '^([0-9])+/(s|min|second|minute|hour|day)$' "${upto}"; then
            limit_params="${limit_params} --hashlimit-upto ${upto}"
          else
            echo_fatl "\"${upto}\" is not a valid params for --upto"
          fi
        fi

        if [ -n "${above}" ]; then
          if yx_str_checkfmt '^([0-9])+/(s|min|second|minute|hour|day)$' "${above}"; then
            limit_params="${limit_params} --hashlimit-above ${above}"
          else
            echo_fatl "\"${above}\" is not a valid params."
          fi
        fi

        if [ -n "${burst}" ]; then
          if yx_str_checkfmt '^([0-9])+$' "${burst}"; then
            limit_params="${limit_params} --hashlimit-burst ${burst}"
          else
            echo_fatal "\"${burst}\" is not a valid params"
          fi
        fi

        if [ -n "${mode}" ]; then
          if [ "${mode}" == 'srcip' ] || [ "${mode}" == 'srcport' ] || [ "${mode}" == 'dstip' ] || [ "${mode}" == 'dstport' ]; then
            limit_params="${limit_params} --hashlimit-mode ${mode}"
          else
            echo_fatal "\"${mode}\" is not a valid params.mode must be following items:srcip,srcport,dstip,dstport. Mutiple item separate by comma(,)"
          fi
        fi

        if [ -n "${srcmask}" ]; then
          if [[ "${srcmask}" =~ ^[0-3][0-9]?$ ]]  &&  [ "${srcmask}" -le 32 ]; then
            limit_params="${limit_params} --hashlimit-srcmask ${srcmask}"
          else
            echo_fatal "\"${srcmask}\" is not a valid params. srcmask must be between 0 and 32."
          fi
        fi

        if [ -n "${dstmask}" ]; then
          if [[ "${dstmask}" =~ ^[0-3][0-9]?$ ]]  &&  [ "${dstmask}" -le 32 ]; then
            limit_params="${limit_params} --hashlimit-dstmask ${dstmask}"
          else
            echo_fatal "\"${dstmask}\" is not a valid params. dstmask must be between 0 and 32."
          fi
        fi

        if [ -n "${expire}" ]; then
          if [[ "${expire}" =~ ^[1-9][0-9]*$ ]]; then
            limit_params="${limit_params} --hashlimit-htable-expire ${expire}"
          else
            echo_fatal "\"${expire}\" is not a valid params."
          fi
        fi

        if [ -n "${gc}" ]; then
          if [[ "${gc}" =~ ^[1-9][0-9]*$ ]]; then
            limit_params="${limit_params} --hashlimit-htable-gcinterval ${gc}"
          else
            echo_fatal "\"${gc}\" is not a valid params."
          fi
        fi

      fi ## end of [ -z "${name}" ]

    fi

  fi

  echo "${limit_params}"
}

# <limit>:<limit val>:[burst]
function _parse_limit_limit()
{
  local limitstr=$1
  local limit=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $2}')
  local burst=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $3}') 

  local limit_params=''
  if [ -n "${limit}" ]; then

    limit_params=' -m limit'

    # --limit
    if yx_str_checkfmt '^([0-9])+/(s|min|second|minute|hour|day)$' "${limit}"; then
      limit_params="${limit_params} --limit ${limit}"
    else
      echo_fatl "\"${limit}\" is not a valid params for above"
    fi


    # --limit-burst
    if [[ -n ${burst} ]]; then
      if yx_str_checkfmt '^([0-9])+$' "${burst}"; then
        limit_params="${limit_params} --limit-burst ${burst}"
      else
        echo_fatal "\"${burst}\" is not a valid params for --limit"
      fi
    fi

  fi

  echo "${limit_params}"
}

# <limit-above/limit-upto>:<name>:<limit val>:[burst]:[mode]:[srcmask]:[dstmask]:[expire]:[tc]
function _parse_limit_hashlimit()
{
  local limitstr=$1
  local control=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $1}')
  local name=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $2}')
  local limit=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $3}')
  local burst=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $4}')
  local mode=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $5}')
  local srcmask=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $6}')
  local dstmask=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $7}')
  local expire=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $8}')
  local gc=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $9}')

  local above=
  local upto=
  if [ "${control}" == 'limit-above' ]; then
    above="${limit}"
  elif [ "${control}" == 'limit-upto' ]; then
    upto="${limit}"
  fi

  local limit_params=''
  if [ -n "${name}" ]; then

    limit_params=" -m hashlimit --hashlimit-name ${name}"

    if [ -n "${upto}" ]; then
      if yx_str_checkfmt '^([0-9])+/(s|min|second|minute|hour|day)$' "${upto}"; then
        limit_params="${limit_params} --hashlimit-upto ${upto}"
      else
        echo_fatl "\"${upto}\" is not a valid params for --upto"
      fi
    fi

    if [ -n "${above}" ]; then
      if yx_str_checkfmt '^([0-9])+/(s|min|second|minute|hour|day)$' "${above}"; then
        limit_params="${limit_params} --hashlimit-above ${above}"
      else
        echo_fatl "\"${above}\" is not a valid params."
      fi
    fi

    if [ -n "${burst}" ]; then
      if yx_str_checkfmt '^([0-9])+$' "${burst}"; then
        limit_params="${limit_params} --hashlimit-burst ${burst}"
      else
        echo_fatal "\"${burst}\" is not a valid params"
      fi
    fi

    if [ -n "${mode}" ]; then
      if [ "${mode}" == 'srcip' ] || [ "${mode}" == 'srcport' ] || [ "${mode}" == 'dstip' ] || [ "${mode}" == 'dstport' ]; then
        limit_params="${limit_params} --hashlimit-mode ${mode}"
      else
        echo_fatal "\"${mode}\" is not a valid params.mode must be following items:srcip,srcport,dstip,dstport. Mutiple item separate by comma(,)"
      fi
    fi

    if [ -n "${srcmask}" ]; then
      if [[ "${srcmask}" =~ ^[0-3][0-9]?$ ]]  &&  [ "${srcmask}" -le 32 ]; then
        limit_params="${limit_params} --hashlimit-srcmask ${srcmask}"
      else
        echo_fatal "\"${srcmask}\" is not a valid params. srcmask must be between 0 and 32."
      fi
    fi

    if [ -n "${dstmask}" ]; then
      if [[ "${dstmask}" =~ ^[0-3][0-9]?$ ]]  &&  [ "${dstmask}" -le 32 ]; then
        limit_params="${limit_params} --hashlimit-dstmask ${dstmask}"
      else
        echo_fatal "\"${dstmask}\" is not a valid params. dstmask must be between 0 and 32."
      fi
    fi

    if [ -n "${expire}" ]; then
      if [[ "${expire}" =~ ^[1-9][0-9]*$ ]]; then
        limit_params="${limit_params} --hashlimit-htable-expire ${expire}"
      else
        echo_fatal "\"${expire}\" is not a valid params."
      fi
    fi

    if [ -n "${gc}" ]; then
      if [[ "${gc}" =~ ^[1-9][0-9]*$ ]]; then
        limit_params="${limit_params} --hashlimit-htable-gcinterval ${gc}"
      else
        echo_fatal "\"${gc}\" is not a valid params."
      fi
    fi
  fi

  echo "${limit_params}"
}

# <recent-set,remove,update,check>:<name>:<seconds>:[hitcount]:[src,dest,ttl]
# src is default value
function _parse_limit_recent()
{
  local limitstr=$1
  local control=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $1}')
  local name=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $2}')
  local seconds=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $3}')
  local hitcount=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $4}')
  local optional=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $5}')


  local limit_params=''
  if [ -n "${name}" ] && [ -n "${control}" ]; then

    limit_params=" -m recent"

    control=${control#recent-}
    local -a control_array
    IFS=',' read -r -a control_array <<< "${control}"
    for opt in "${control_array[@]}"; do
      if [ "${opt}" == 'set' ]; then
        limit_params="${limit_params} --set"
      elif [ "${opt}" == 'remove' ]; then
        limit_params="${limit_params} --remove"
      elif [ "${opt}" == 'update' ]; then
        limit_params="${limit_params} --update"
      elif [ "${opt}" == 'check' ]; then
        limit_params="${limit_params} --rcheck"
      else
        echo_fatal "Invalid limit optional. Unknown optional:${opt}"
      fi
    done


    limit_params="${limit_params} --name ${name}"

    if [ -n "${seconds}" ]; then
      limit_params="${limit_params} --seconds ${seconds}"
    fi

    if [ -n "${hitcount}" ]; then
      limit_params="${limit_params} --hitcount ${hitcount}"
    fi


    if [ -n "${optional}" ]; then
      local -a optional_array
      IFS=',' read -r -a optional_array <<< "${optional}"
      for opt in "${optional_array[@]}"; do
        if [ "${opt}" == 'src' ]; then
          limit_params="${limit_params} --rsource"
        elif [ "${opt}" == 'dest' ]; then
          limit_params="${limit_params} --rdest"
        elif [ "${opt}" == 'ttl' ]; then
          limit_params="${limit_params} --rttl"
        else
          echo_fatal "Invalid limit optional. Unknown optional:${opt}"
        fi
      done
    fi

  fi

  echo "${limit_params}"
}

# <length>:<length>
function _parse_limit_length()
{
  local limitstr=$1
  local length=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $2}')

  local limit_params=''
  if [ -n "${length}" ]; then
    if [[ "${length}" =~ ^[0-9]+$ ]]; then
      limit_params=" -m length --length ${length}"
    else
      echo_fatl "Invalid limit params:${length}"
    fi
  fi

  echo "${limit_params}"
}

# <connect-above/connect-upto>:<limit>:[src/dest]:[mask]
function _parse_limit_connection()
{
  local limitstr=$1
  local control=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $1}')
  local limit=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $2}')
  local target=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $3}')
  local mask=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $4}')

  local limit_params=''
  if [ -n "${limit}" ]; then

    if [[ ! "${limit}" =~ ^[1-9][0-9]*$ ]]; then
      echo_fatal "Invalid limit value:${limit}"
    fi


    limit_params='-m connlimit'
    
    if [ "${control}" == 'connect-above' ]; then
      limit_params="${limit_params} --connlimit-above ${limit}"
    elif [ "${control}" == 'connect-upto' ]; then
      limit_params="${limit_params} --connlimit-upto ${limit}"
    else
      echo_fatal "Unknown limit params:${control}"
    fi

    if [ -n "${target}" ]; then
      if [ "${target}" == 'src' ]; then
        limit_params="${limit_params} --connlimit-saddr"
      elif [ "${target}" == 'dest' ]; then
        limit_params="${limit_params} --connlimit-daddr"
      else
        echo_fatal "Unknown limit target:${target}"
      fi
    fi

    if [ -n "${mask}" ]; then
      # for ipv4, 0<=mask<=32. for ipv6, 0<=mask<=128
      # do not support ipv6
      if [[ ${mask} =~ ^[1-9][0-9]*$ ]] && [ "${mask}" -le 32 ]; then
        limit_params="${limit_params} --connlimit-mask ${mask}"
      fi
    fi

  fi # end of if [ -n "${limit}" ]; then

  echo "${limit_params}"
}

# <time>:<starttime>:<endtime>:<weekdays>:<monthdays>
function _parse_limit_time()
{
  local limitstr=$1
  local start_time=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $2}')
  local end_time=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $3}')
  local weekdays=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $4}')
  local monthdays=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $5}')

  local limit_params=''

  if [ -n "${start_time}" ] && [ -n "${end_time}" ] || [ -n "${weekdays}" ] || [ -n "${monthdays}" ]; then

    limit_params='-m time'

    # <starttime>:<endtime>
    if [ -n "${start_time}" ] && [ -n "${end_time}" ]; then

      start_time=$(echo "${start_time}" | tr '#' ':')
      end_time=$(echo "${end_time}" | tr '#' ':')

      time_val=()
      for time in $(echo "${start_time} ${end_time}"); do
        if [[ ! "${time}" =~ ^[0-2][0-9]:[0-5][0-9](:[0-5][0-9])?$ ]]; then
          echo_fatal "Invalid time format:${time}"
        fi

        hh=$(echo "${time}" | awk 'BEGIN{FS=":"}{print $1}')
        mm=$(echo "${time}" | awk 'BEGIN{FS=":"}{print $2}')
        ss=$(echo "${time}" | awk 'BEGIN{FS=":"}{print $3}')
        if [ -z "${ss}" ]; then
          ss='00'
        fi
	
        time_val=(${time_val[@]} "${hh}${mm}${ss}")
      done

      limit_params="${limit_params} --timestart ${start_time}"
      limit_params="${limit_params} --timestop ${end_time}"

      # --contiguous
      if [ "${time_val[0]}" -gt "${time_val[1]}" ]; then
        limit_params="${limit_params} --contiguous"
      fi

    fi # end of  if [ -n "${start_time}" ] && [ -n "${end_time}" ];

    # <weekdays>
    if [ -n "${weekdays}" ]; then
      local fix_weekdays=$(fixstr "${weekdays}" "Mon Tue Wed Thu Fri Sat Sun 1 2 3 4 5 6 7")
      if [ -n "${fix_weekdays}" ]; then
        limit_params="${limit_params} --weekdays ${fix_weekdays}"
      else
        echo_fatal "Invalid weekdays format:${weekdays}"
      fi
    fi

    # <monthdays>
    if [ -n "${monthdays}" ]; then
      if [ "${monthdays}" -ge 1 ] && [ "${monthdays}" -le 31 ]; then
        limit_params="${limit_params} --monthdays ${monthdays}"
      fi
    fi

    #kerneltz
    limit_params="${limit_params} --kerneltz"
  fi


}

function _parse_limit2()
{
  local -a limitstr_array=
  IFS=';' read -r -a limitstr_array <<< "${1}"

  local limit_params=''
  for limitstr in "${limitstr_array[@]}"; do

    local module=$(echo "${limitstr}" | awk 'BEGIN{FS=":"}{print $1}')

    if [ "${module}" == 'limit' ]; then
      limit_params="${limit_params} $(_parse_limit_limit ${limitstr})"
    elif [ "${module}" == 'limit-above' ]  ||  [ "${module}" == 'limit-upto' ]; then
      limit_params="${limit_params} $(_parse_limit_hashlimit ${limitstr})"
    elif [ "${module}" == 'length' ]; then
      limit_params="${limit_params} $(_parse_limit_length ${limitstr})"
    elif [ "${module}" == 'connect' ]; then
      limit_params="${limit_params} $(_parse_limit_connection ${limitstr})"
    elif [ "${module}" == 'time' ]; then
      limit_params="${limit_params} $(_parse_limit_time ${limitstr})"
    elif [[ "${module}" =~ ^recent-.+$ ]]; then
    # elif [ "${module}" == 'recent-set' ] || [ "${module}" == 'recent-remove' ] || [ "${module}" == 'recent-update' ] || [ "${module}" == 'recent-check' ]; then
      limit_params="${limit_params} $(_parse_limit_recent ${limitstr})"
    fi

  done

  echo "${limit_params}"

}


####################################################################################################
# usage
####################################################################################################


function usage() {
cat <<EOF
  usage: ${CMD} <sub-command> <optional>
  For IPV4 package filtering and nat

  usage: ${CMD} <--help|-h> 
  For this help information.

  usage: ${CMD} <sub-command> <--help|-h>
  For detail information for sub-command.

  usage: ${CMD} <--version|-v> 
  Show script version.

  The following sub-command are allowed:
  start:    Start the firewall service
  clear:    Clear all rules and custom chain.
  save:     Save firewall change on next startup.
  default:  Set or display the default policy to filter table
  config:   Read, write or remove the config file on global or specific domain.
  list:     List rule information with the selected chain.
  chain:    Create ,search or display the custom chain.
  nat:      SNAT or DNAT IPV4 package
  filter:   Filter IPV4 package.
  incoming: For IPV4 incoming package filtering
  outgoing: For IPV4 outgoing filtering
  server:   For 'New' connection on incoming and 'Established/Relate' connection on outgoing.
  client:   For 'New' connection on outgoing and 'Established/Relate' connection on incoming.
  loopback: Fast command for loopback interface.
  handler:  Manager handler command.

  Other options
  Use '${CMD} --help' show this help information
  
Handler:
$(iptables_handler list --retraction 2)

Known ports:
$(show_wellknown_port)
EOF
}

function usage_start() {
cat <<EOF
  usage: ${CMD} start [--info-level xxx]
  Start the firewall service

  The followint option are availiable:
  --info-level     Command output level. 
                   The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                   or a number greater than 0.

                   You can use ${CMD} config to get or set it as the global value. 
                      ${CMD} config --write --key info.level --val debug
                      ${CMD} config --read --key info.level

                   Use '${CMD} config --help' to see more information.

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function usage_clear() {
cat <<EOF
  usage: ${CMD} clear [--info-level xxx]
  Clear all rule and custom chain.

  usage: ${CMD} clear <--help|-h> 
  For this help information.

  The followint option are availiable:
  --info-level     Command output level. 
                   The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                   or a number greater than 0.

                   You can use ${CMD} config to get or set it as the global value. 
                      ${CMD} config --write --key info.level --val debug
                      ${CMD} config --read --key info.level

                   Use '${CMD} config --help' to see more information.


  Other options
  Use '${CMD} --help' show all help information

EOF
}

function usage_save() {
cat <<EOF
  usage: ${CMD} save [option] 
  Save the firewall change on next startup

  usage: ${CMD} save <--help|-h> 
  For this help information.

  The followint option are availiable:
  --info-level     Command output level. 
                   The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                   or a number greater than 0.

                   You can use ${CMD} config to get or set it as the global value. 
                      ${CMD} config --write --key info.level --val debug
                      ${CMD} config --read --key info.level

                   Use '${CMD} config --help' to see more information.
                  

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function usage_default() {
cat <<EOF
  usage: ${CMD} default <accept|drop> [options]
  Set default policy to filter table. 
  NOTE: This command will always change all IPv6 policy to 'DROP'

  usage: ${CMD} default <--list|-l> [options]
  Show default policy to specific filter table

  usage: ${CMD} default <--help|-h> 
  For this help information.

  The following options are allowed:
  --input   <ACCEPT|DROP>   add input chain to target
  --output  <ACCEPT|DROP>   add output chain to target
  --forward <ACCEPT|DROP>   add forward chain to target
  --all     <ACCEPT|DROP>   add all chain to target

  --list     show default policy to specific filter table

  --info-level     Command output level. 
                   The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                   or a number greater than 0.

                   You can use ${CMD} config to get or set it as the global value. 
                      ${CMD} config --write --key info.level --val debug
                      ${CMD} config --read --key info.level

                   Use '${CMD} config --help' to see more information.


  -h|--help     show this help information

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function usage_chain() {
  cat <<EOF
  usage: ${CMD} chain <create|remove> --name <name> [option] 
  Create or remove a custom chain.

  usage: ${CMD} chain exist --name <name> [option] 
  Test whether a chain exist

  usage: ${CMD} chain list [option] 
  List all chains on specific table.

  usage: ${CMD} chain <--help|-h> 
  For this help information.

  The followint option are availiable:
  --table          The table of the operation. The default value is 'filter'

  --name           Indicate the chain name. 
  
  --custom-only    When list all rules, ignore common rule(INPUT,FORWARD,OUTPUT,PREROUTING,POSTROUTING)

  --chain-io       handle 'chain_name' as 'chain_name_in' and 'chain_name_out'

  --info-level     Command output level. 
                   The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                   or a number greater than 0.

                   You can use ${CMD} config to get or set it as the global value. 
                      ${CMD} config --write --key info.level --val debug
                      ${CMD} config --read --key info.level

                   Use '${CMD} config --help' to see more information.
                  

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function usage_filter()
{
  cat <<EOF
  usage: ${CMD} filter <ACCEPT|DROP|BLOCK|RETURN|REJECT|REJECT-WITH|LOG> [options]
  For IPV4 package filtering. It's a wrapper of iptables.

  usage: ${CMD} filter <--help|-h> 
  For this help information.

  The following options are allowed:

  --chain              If indicate a name, command will create custom chain with name_in and name_out.

  --fragment           The rule only refers to second and further IPv4 fragments of fragmented packets.
  --not-fragment       Same as --fragment. but sense is inverted.

  --interface-in       Name of an interface via which a package was received.
  --interface-out      Name of an interface via which a package was send out.
  --not-interface-in   Same as '--interface-in' but sense is inverted.
  --not-interface-out  Same as '--interface-out' but sense is inverted.

  --proto              The protocol of the rule or of the packet to check. The specified protocol can be one of 'tcp'
                       , 'udp', 'udplite', 'icmp', 'esp', 'ah', 'sctp', 'mh' or the special keyward 'all', or it can 
                       be a numeric value, representing one of these protocols or a different one.
  --proto-flag         Addition optional of iptables flags. 

  --mac                Indicate a mac-address. (e.g. 11:22:33:44:55:66)
  --notmac             Same as '--mac' but sense is inverted.

  --ip-from            Indicate ip-address from incomming connection. (support ip format: 192.168.0.1 | 192.168.0.1/24 | 192.168.0.1-192.168.0.99)
  --not-ip-from        Same as '--ip-from' but sense is inverted.
  --ip-to              Indicate ip-address from outgoing connection (support ip format: 192.168.0.1 | 192.168.0.1/24 | 192.168.0.1-192.168.0.99)
  --not-ip-to          Same as 'ip-to' but sense is inverted.

  --port-from          Indicate ports for incomming connection. (use ',' for muti-port num. port1,port2,...)
  --port-to            Indicate ports for outgoing connection. (use ',' for muti-port num. port1,port2,...)

  --limit              Set the rule limit. the following limit are support. You can indicate mutiple limit in one command.
                          1. <limit>:<limit val>:[burst]
                          2. <limit-above/limit-upto>:<name>:<limit val>:[burst]:[mode]:[srcmask]:[dstmask]:[expire]:[tc]
                          3. <recent-set,remove,update,check>:<name>:<seconds>:[hitcount]:[src,dest,ttl]
                          4. <length>:<length>
                          5. <connect-above/connect-upto>:<limit>:[src/dest]:[mask]
                          6. <time>:<starttime>:<endtime>:<weekdays>:<monthdays>
  
  --state              State of the package. It can be the following values: NEW, ESTABLISHED, RELATED, INVALID, UNTRACKED.
  
  --log                Record a log when rule break. The parmater format is '--log <prifix>:[rule-limit]'. 
                       The rule-limit is the same format as `--limt` string. Use '-' to re-use the previous --limit string.

  --info-level         Command output level. 
                       The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                       or a number greater than 0.

                       You can use ${CMD} config to get or set it as the global value. 
                          ${CMD} config --write --key info.level --val debug
                          ${CMD} config --read --key info.level

                       Use '${CMD} config --help' to see more information.

  --help|-h            Show this help information


  Other options
  Use '${CMD} --help' show all help information
EOF
}


function usage_nat() {
cat <<EOF
  usage: ${CMD} nat <--snat|dnat> --from-inter xxx --to-inter xx [--log]
  For IPV4 package NAT(Network Address Translation).

  usage: ${CMD} nat --list
  Show nat rule information.

  usage: ${CMD} nat <--help|-h> 
  For this help information.

  The following options are allowed:
  --list        List nat rule information.
  --snat        Command work as SNAT(Source Network Address Translatioon)
  --dnat        Command work as DNAT(Destination Network Address Translation)

  --from-inter  Name of an interface which the source network durning the address translation.
  --to-inter    Name of an interface which the destination network during the address translatioon.

  --log         Record log on forward request

  --info-level  Command output level. 
                The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                or a number greater than 0.

                You can use ${CMD} config to get or set it as the global value. 
                  ${CMD} config --write --key info.level --val debug
                  ${CMD} config --read --key info.level

                Use '${CMD} config --help' to see more information.

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function usage_wall()
{
  cat <<EOF
  usage: ${CMD} Incmong <accept|drop|block|return|reject> [options]
  For IPV4 incoming package filtering

  usage: ${CMD} Outgoing <accept|drop|block|return|reject> [options]
  For IPV4 outgoing filtering

  usage: ${CMD} Server <accept|drop|block|return|reject> [options]
  For 'New' connection on incoming and 'Established/Relate' connection on outgoing.

  usage: ${CMD} Client <accept|drop|block|return|reject> [options]
  For 'New' connection on outgoing and 'Established/Relate' connection on incoming.


  The following options are allowed:

  --chain          If indicate a name, command will create custom chain with name_in and name_out.

  --interface      Name of an interface via which a package was received. '*' means all interface.
  --not-interface  Same as '--interface' but sense is inverted.

  --ip             Indicate ip-address from incomming connection. (support ip format: 192.168.0.1 | 192.168.0.1/24 | 192.168.0.1-192.168.0.99)
  --not-ip         Same as '--ip' but sense is inverted.
  --force-ip       Convert all interface to ip/mask.

  --mac            Indicate a mac-address. (e.g. 11:22:33:44:55:66)
  --notmac         Same as '--mac' but sense is inverted.

  --net            Same as --ip or --intreface. the command will test what the prameters is.

  --port           Indicate ip-address from incomming connection.

  --proto          The protocol of the rule or of the packet to check. There is 4 types protocol support:

                      1. The specified protocol can be one of 'tcp' , 'udp', 'udplite', 'icmp', 'esp', 'ah', 'sctp',
                          'mh' or the special keyward 'all', or it can be a numeric value, representing one of these protocols or a different one.
                      2. Some great known protocol with port number in DEFAULT_PORT dictionary.
                      3. The protocol regist in hook handler. Handler applies more precise and strict rules to these protocols
                      4. dummy-protocol:
                              wall-broadcast: for broadcast package
                              wall-pkg: for invalid package
                              wall-synflood: for syn-flood package
                              wall-scan: for stealth-scan package

  --proto-flag     Addition optional of iptables flags. 

  --limit          Set the rule limit. the following limit are support. You can indicate mutiple limit in one command.
                   1. <limit>:<limit val>:[burst]
                   2. <limit-above/limit-upto>:<name>:<limit val>:[burst]:[mode]:[srcmask]:[dstmask]:[expire]:[tc]
                   3. <recent-set,remove,update,check>:<name>:<seconds>:[hitcount]:[src,dest,ttl]
                   4. <length>:<length>
                   5. <connect-above/connect-upto>:<limit>:[src/dest]:[mask]
                   6. <time>:<starttime>:<endtime>:<weekdays>:<monthdays>
  
  --log            Record a log when rule break. The parmater format is '--log <prifix>:[rule-limit]'. 
                   The rule-limit is the same format as `--limt` string. Use '-' to re-use the previous --limit string.
                   

  --info-level     Command output level. 
                   The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                    or a number greater than 0.

                   You can use ${CMD} config to get or set it as the global value. 
                     ${CMD} config --write --key info.level --val debug
                     ${CMD} config --read --key info.level

                     Use '${CMD} config --help' to see more information.

  --help|-h        Show this help information

  Other options
  Use '${CMD} --help' show all help information

Handler:
$(iptables_handler list --retraction 2)

Known ports:
$(show_wellknown_port)

EOF
}


function usage_loopback() {
cat <<EOF
  usage: ${CMD} loopback <ACCEPT|DROP> [-infolevel xxx]
  Fast command for loopback interface.


  --info-level     Command output level. 
                   The specific level can be one of 'silent', 'fatal', 'error', 'warning',
                   'notice, 'info', 'debug', or a number greater than 0.

                   You can use ${CMD} config to get or set it as the global value. 
                     ${CMD} config --write --key info.level --val debug
                     ${CMD} config --read --key info.level

                     Use '${CMD} config --help' to see more information.


  Other options
  Use '${CMD} --help' show all help information

  NOTE: In this command, you should ignore '--interface' and '--not-interface' optional.

EOF
}


function usage_config() {
  cat <<EOF
  usage: ${CMD} domain <--read|--remove> <--key keyval>
  Read or remove a key-value item on domain config file. If not provide a domain, use 'config' as default

  usage: ${CMD} domain <--write> <--key keyval> <--val val>
  Write a key-value item on domain config file. If not provide a domain, use 'config' as default

  usage: ${CMD} Wall <--help|-h> 
  For this help information.


  The following domain are support:
  config        The global domain.
                Support comfiguration items:
                info.level :debug level. Same as --info-level optional, But work on gobal.

  rule.<proto>  domain on specific protocol (TODO)
                Support comfiguration items:
                protocol=xxx
                port=xxx


  The following options are allowed:
  --read       read a value of the config file on specific domain.
  --write      write a key-value item on specific domain.
  --remove     remove a key-value item on specific domain.

  --key        key of the key-value config item.
  --val        value of the key-value config item.

  --info-level     Command output level. 
                   The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                    or a number greater than 0.

                   You can use ${CMD} config to get or set it as the global value. 
                     ${CMD} config --write --key info.level --val debug
                     ${CMD} config --read --key info.level

                     Use '${CMD} config --help' to see more information.

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function usage_list()
{
   cat <<EOF
  usage: ${CMD} list [--table|--numeric|--verbose|--line-num|--chain-io|--reference|] 
  List all rules in the select chain. If no chain is selected, all chains are list.

  usage: ${CMD} list <chain_name> [--table|--numeric|--verbose|--line-num|--chain-io|--reference|] 
  List rule information with the selected chain.

  usage: ${CMD} list <--help|-h> 
  For this help information.


  The following options are allowed:

  --table      This option specifies the packet matching table which the command should operate on.
  --numeric    Numeric output. IP addresses and port numbers will be printed in numeric format.
  --verbose    Verbose output. This option makes the list command show the interface name, the rule options (if any), and the TOS masks.
  --line-num   When listing rules, add line numbers to the beginning of each rule.

  --chain-io   When indicate a chain 'name', --chain-io display both 'name_in' and 'name_out' as chain name at same time
  --reference  When indicate a chain 'name', --reference display all reference information at the end of chain.


  --info-level     Command output level. 
                   The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                    or a number greater than 0.

                   You can use ${CMD} config to get or set it as the global value. 
                     ${CMD} config --write --key info.level --val debug
                     ${CMD} config --read --key info.level

                     Use '${CMD} config --help' to see more information.

  Other options
  Use '${CMD} --help' show all help information 
EOF
}


function usage_handler()
{
cat <<EOF
  usage: ${CMD} handler list [--protocol] 
  List handler information in the selected protocol. If no protocol is selected, a handler-list will display

  usage: ${CMD} list <--help|-h> 
  For this help information.


  The following options are allowed:
  --protocol       Specifiec a protocol to show detail handler information.


  --retraction     Controls the number of spaces to shrink
  --info-level     Command output level. 
                   The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                    or a number greater than 0.

                   You can use ${CMD} config to get or set it as the global value. 
                     ${CMD} config --write --key info.level --val debug
                     ${CMD} config --read --key info.level

                     Use '${CMD} config --help' to see more information.

  Other options
  Use '${CMD} --help' show all help information 
EOF
}


function usage_storage()
{
cat <<EOF
  usage: ${CMD} buckup <--path path> [--force] 
  Buckup current configuration, include iptables' rule, network and netfilter optimization parameters.

  usage: ${CMD} restore <--path path> [--force]
  Restore all network configurate from a buckup file.

  usage: ${CMD} --help
  For this help information.


  The following options are allowed:

  --path       Path of the buckup file.
  --force      if an existing buckup file exist, remove it and try again.

  --tmp-path   Indicate a directory to storage mid files. for debugging.

  --info-level     Command output level. 
                   The specific level can be one of 'silent', 'fatal', 'error', 'verbose',
                    or a number greater than 0.

                   You can use ${CMD} config to get or set it as the global value. 
                     ${CMD} config --write --key info.level --val debug
                     ${CMD} config --read --key info.level

                     Use '${CMD} config --help' to see more information.

  Other options
  Use '${CMD} --help' show all help information 
EOF
}

####################################################################################################
# conf
####################################################################################################

function create_script_init()
{

  local path_v4=
  local path_v6=

  while [ $# -gt 0 ]; do
		case $1 in
		--path )
			shift
			path_v4=$1
		;;

    --path-ip6 )
			shift
			path_v6=$1
		;;

		*)
			echo_fatal "Invalid optional ${1}"
		;;
		esac
		shift
	done


  local v4_store_cmd=''
  if [ -f "${path_v4}" ]; then
    v4_store_cmd="${IPTABLES_RESTORE} < '${path_v4}'"
  fi

  local v6_store_cmd=''
  if [ -f "${path_v6}" ]; then
    v6_store_cmd="${IP6TABLES_RESTORE} < '${path_v6}'"
  fi


cat <<EOF
#!/bin/bash

### BEGIN INIT INFO
# Provides:          Yuxi Liu
# Required-Start:
# Required-Stop:
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: "${CMD}" startup script
# Description:       "${CMD}" startup script. It apply firewall rule on startup, pre network.
### END INIT INFO


set -e

PATH="/bin:/sbin:/usr/sbin"

start() {
  ${v4_store_cmd}
  ${v6_store_cmd}
  exit 0
}

case "\$1" in
  start)
    start
    ;;

  *)
    echo "Usage: ${CMD} {start}"
    exit 1
esac

eixt 0

EOF

}

function create_ubuntu_service_config()
{
  local path=

  while [ $# -gt 0 ]; do
		case $1 in
		--path )
			shift
			path=$1
		;;

		*)
			echo_fatal "Invalid optional ${1}"
		;;
		esac
		shift
	done


cat <<EOF
[Unit]
Description = Apply base firewall rules

[Service]
Type=oneshot
ExecStart=${path} start

[Install]
WantedBy=network-pre.target
EOF
}


function save_iptabls_dump()
{
  local iptables_dump_path=
  local ip6tables_dump_path=

  while [ $# -gt 0 ]; do
		case $1 in
		--iptables-dump )
			shift
			iptables_dump_path=$1
		;;

    --ip6tables-dump )
			shift
			ip6tables_dump_path=$1
		;;

		*)
			echo_fatal "Invalid optional ${1}"
		;;
		esac
		shift
	done


  if [ ! -d  "${RULE_DIR}" ]; then
      echo_err "DIR ${RULE_DIR} not exist, try create one"
      echo_cmd "mkdir -p ${RULE_DIR}"
      if [ ! -d  "${RULE_DIR}" ]; then
        echo_fatal "Failed to mkdir ${RULE_DIR}"
      fi
  fi

  # Create iptables rule file in /etc/systemd/
  local rule_file_ok=false
  local rule_file="${RULE_DIR}/${RULE_FILENAME_v4}".rules
  # echo_verbose "Remove old rule file:${rule_file} ..."
  if [ -n "${iptables_dump_path}" ]; then
    if ! [ -f "${iptables_dump_path}" ]; then
      echo_fatal "iptables' dump file not exist :${iptables_dump_path}"
    fi
    if ! ${IPTABLES_RESTORE} --test ${iptables_dump_path}; then
      echo_fatal "iptables' dump file parse error :${iptables_dump_path}"
    fi

    echo_verbose "Create iptables dump file:${rule_file} ..."
    echo_cmd "rm -f ${rule_file}"
    echo_cmd "cp --force ${iptables_dump_path} ${rule_file}"
    if [[ $? == 0 ]]; then
      rule_file_ok=true
    else
      echo_fatal "Failed to create iptables dump file"
    fi
  fi

  # Create ip6tables rule file in /etc/systemd/
  local rule6_file_ok=false
  local rule6_file="${RULE_DIR}/${RULE_FILENAME_v6}".rules
  # echo_verbose "Remove old rule file:${rule6_file} ..."
  if [ -n "${ip6tables_dump_path}" ]; then
    if ! [ -f "${ip6tables_dump_path}" ]; then
      echo_fatal "ip6tables' dump file not exist :${ip6tables_dump_path}"
    fi
    if ! ${IP6TABLES_RESTORE} --test ${ip6tables_dump_path}; then
      echo_fatal "ip6tables' dump file parse error :${ip6tables_dump_path}"
    fi

    echo_verbose "Create ip6tables dump file:${rule6_file} ..."
    echo_cmd "rm -f ${rule6_file}"
    echo_cmd "cp --force ${ip6tables_dump_path} ${rule6_file}"
    if [[ $? == 0 ]]; then
      rule6_file_ok=true
    else
      echo_fatal "Failed to create ip6tables dump file"
    fi
  fi


  if ${rule_file_ok} && ${rule6_file_ok}; then

    # Create init.d script
    echo_verbose "Create init.d script:${INITD_SCRIPT_PATH} ..."
    local initd_script_dir=$(dirname "${INITD_SCRIPT_PATH}")
    if [ ! -d "${initd_script_dir}" ]; then
      echo_err "DIR ${initd_script_dir} not exist, try create one"
      echo_cmd "mkdir -p ${initd_script_dir}"
      if [ ! -d "${initd_script_dir}" ]; then
        echo_fatal "Failed to mkdir ${initd_script_dir}"
      fi
    fi

    local script_params=''
    if ${rule_file_ok}; then
      script_params="${script_params} --path ${rule_file}"
    fi
    if ${rule6_file_ok}; then
      script_params="${script_params} --path-ip6 ${rule6_file}"
    fi

    create_script_init ${script_params} > "${INITD_SCRIPT_PATH}"
    echo_cmd "${CHMOD} 0766 ${INITD_SCRIPT_PATH}"



    # Create systemctl service config.
    echo_verbose "Create systemd service config:${SYSTEMD_INIT_PATH} ..."
    local systemd_init_dir=$(dirname ${SYSTEMD_INIT_PATH})
    if [ ! -d "${systemd_init_dir}" ]; then
      echo_err "DIR ${systemd_init_dir} not exist, try create one"
      echo_cmd "mkdir -p ${systemd_init_dir}"
      if [ ! -d "${systemd_init_dir}" ]; then
        echo_fatal "Failed to mkdir ${systemd_init_dir}"
      fi
    fi

    create_ubuntu_service_config --path "${INITD_SCRIPT_PATH}" > "${SYSTEMD_INIT_PATH}"

  fi

  

}


####################################################################################################
# iptables
####################################################################################################

function iptables_config()
{
    local option=
    local key=
    local val=

    local show_help=false
    local info_level=


    local domain=$1
    if ! [[ "${domain}" =~ ^-.*$ ]]; then
      shift
    else
      domain='config'
    fi


    while [ $# -gt 0 ]; do
		case $1 in

      --read )
        option='read'
      ;;

      --write )
        option='write'
      ;;

      --remove )
        option='remove'
      ;;

      --list )
        option='list'
      ;;

      --key )
        shift
        key=$1
      ;;

      --val )
        shift
        val=$1
      ;;

      --info-level )
        shift
        info_level=$1
			;;

			--help )
				show_help=true
			;;

      *)
        echo_fatal "Invalid optional ${1}"
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_config
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    if [ -z "${domain}" ]; then
      echo_fatal "Domain is empty"
    fi


    local config_file="${CONFIG_DIR}/$(echo ${domain} | tr '.' '/' | tr '[:upper:]' '[:lower:]' | grep -o '[^ ]\+\( \+[^ ]\+\)*').conf"
    local config_dir=$(dirname "${config_file}")
    if [ ! -d  "${config_dir}" ]; then
        echo_err "DIR ${config_dir} not exist, try create one"
        #echo_cmd "mkdir -p ${config_dir}"
        mkdir -p ${config_dir} > /dev/null
        if [ ! -d  "${config_dir}" ]; then
          echo_fatal "Failed to mkdir ${config_dir}"
        fi
    fi


    if [[ "${option}" == 'read' ]]; then

      if [[ -z ${key} ]]; then
        echo_fatal "${CMD} --read config must provide key value, using --key"
      fi

      if [ -r "${config_file}" ]; then
        yx_read_config --file "${config_file}" --key "${key}"
      fi

    elif [[ "${option}" == 'write' ]]; then

      if [[ -z ${key} ]]; then
        echo_fatal "${CMD} --write must provide key property, using --key"
      fi

      if [[ -z ${val} ]]; then
        echo_fatal "${CMD} --write must provide value property, using --val"
      fi

      # 修改了conig脚本，可选择是否支持重复key，所以不需要先删除再添加了。
      # 这个先注释掉，面的逻辑有问题
      # if yx_has_config --file "${config_file}" --key "${key}"; then
      #   echo_verbose "config remove(key=${key} domain=${domain}) on file:${config_file}"
      #   yx_delete_config --file "${config_file}" --key "${key}"
      # fi

      echo_verbose "config write(key=${key} val=${val} domain=${domain}) on file:${config_file}"
      yx_write_config --file "${config_file}" --key "${key}" --val "${val}"
    elif [[ "${option}" == 'remove' ]]; then

      if [[ -z ${key} ]]; then
        echo_fatal "${CMD} --read config must provide key value, using --key"
      fi

      if [ -w "${config_file}" ]; then
        echo_verbose "config remove(key=${key} domain=${domain}) on file:${config_file}"
        yx_delete_config --file "${config_file}" --key "${key}"
      fi

    elif [[ "${option}" == 'list' ]]; then

      if [ -r "${config_file}" ]; then
        cat "${config_file}"
      fi

    else
      echo_fatal "${CMD} config must provide one optional --read, --write or list "
    fi

  fi

}

function iptables_start()
{
  local show_help=false
  local info_level=


  while [ $# -gt 0 ]; do
		case $1 in

      --info-level )
        shift
        info_level=$1
			;;

			--help )
				show_help=true
			;;

			*)
        echo_fatal "Invalid optional ${1}, try '-h' or '--help' to show more information"
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_start
    exit 0
  else
    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    local system=$(linux_type)
    if [[ ${system} == "centos" || ${system} == "debian" ]]; then
      echo_verbose 'Start iptables service...'
      echo_cmd "start iptables.service"
      echo_cmd "enable iptables.service"
    elif [[ ${system} == "ubuntu" ]]; then
      : # do nothing
    else
      :
    fi

  fi

}

function iptables_save()
{
  
  local show_help=false
  local info_level=
  local memsize=

  while [ $# -gt 0 ]; do
		case $1 in

      --info-level )
        shift
        info_level=$1
      ;;

      --memsize )
        shift
        memsize=$1
			;;

			--help )
				show_help=true
			;;

			*)
        echo_fatal "Invalid optional ${1}, try '-h' or '--help' to show more information"
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_save
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi


    if [ -z "${memsize}" ]; then
      memsize=$(yx_mem_total)
    fi

    ###############################
    # CONTRACT_MAX 和 HASHSIZE
    ###############################
    local conntrack_max=$(yx_estimate_conntrack_max "${memsize}")
    if [[ -n "${conntrack_max}" ]]; then
      # 一般大于1GB的系统，CONTRACT_MAX 默认值是 65536
      # 而内存大于2GB时, yx_estimate_conntrack_max 才会计算出大于65536的值
      # 因此，如果内存大于1GB， 但计算出小于65536的值，则不更改配置
      if [[ $(yx_size_to_bytes "${memsize}") -gt $(yx_size_to_bytes 1GB) ]]  &&  [[ "${conntrack_max}" -gt '65536' ]]; then

        #修改 conntrack_max
        if ! yx_sysctl_config --write --key "net.netfilter.nf_conntrack_max" --val "${conntrack_max}"; then
          echo_fatal "failed to change 'net.netfilter.nf_conntrack_max' to ${conntrack_max}"
        fi

        if ! yx_sysctl_config --write --key "net.nf_conntrack_max" --val "${conntrack_max}"; then
          echo_fatal "failed to change 'net.nf_conntrack_max' to ${conntrack_max}"
        fi

        # 修改HASHSIZE
        local hashsize=$((conntrack_max/2))
        if [ -n "${hashsize}" ]; then
            local mod_probe_dir=$(dirname "${NF_CONNTRACK_CONFIG_PATH}")
          if ! [ -d "${mod_probe_dir}" ]; then
            echo_err "DIR ${mod_probe_dir} not exist, try create one"
            echo_cmd "mkdir -p ${mod_probe_dir}"
            if [ ! -d  "${mod_probe_dir}" ]; then
              echo_fatal "Failed to mkdir ${mod_probe_dir}"
            fi
          fi

          # iptables 变更生效，必须带指定的key和value
          yx_modprobe_config --write --refresh --key "options nf_conntrack hashsize" --val "${hashsize}"
        fi

      fi
    fi

    ###############################
    # 响应时间
    ###############################
    #主动方的最后1个状态。默认120秒
    if ! yx_sysctl_config --write --key "net.netfilter.nf_conntrack_tcp_timeout_fin_wait" --val '10'; then
      echo_fatal "failed to change 'net.netfilter.nf_conntrack_tcp_timeout_fin_wait' to 10"
    fi
    # - Linux 里的 MSL 写死 60 秒（而不是 TCP 标准里拍脑袋的 120 秒），TIME_WAIT 要等 2MSL，这里 120 算是个合理的值。
    # - 但现在默认有 PAWS（`net.ipv4.tcp_timestamps`），不会出现标准制定时担心的迷途报文回来碰巧污染了序列号相同的新连接的数据的情况
    # 互联网公司基本都开 `net.ipv4.tcp_tw_reuse`，既然半连接都不留这么久，记录似乎也不需要留这么久。
    if ! yx_sysctl_config --write --key "net.netfilter.nf_conntrack_tcp_timeout_time_wait" --val '10'; then
      echo_fatal "failed to change 'net.netfilter.nf_conntrack_tcp_timeout_time_wait' to 10"
    fi

    # CLOSE_WAIT是被动方收到FIN发ACK，然后会转到LAST_ACK发FIN，除非程序写得有问题，正常来说这状态持续时间很短。#默认 60 秒
    # CLOSE_WAIT 状态是让被动关闭方把该传的数据传完。如果程序写得不好，这里抛了未捕捉的异常，也许就走不到发 FIN 那步了，一直停在这里。
    if ! yx_sysctl_config --write --key "net.netfilter.nf_conntrack_tcp_timeout_close_wait" --val '10'; then
      echo_fatal "failed to change 'net.netfilter.nf_conntrack_tcp_timeout_close_wait' to 10"
    fi

    # 这个值对应的场景是 “双方建立了连接后一直不发包，直到 5天(432000秒)后才发”
    # established_time(默认 432000秒 5天), 理论上不用这么长，不小于 net.ipv4.tcp_keepalive_time 就行了。
    # 默认 keep-alive 超时时间只有 2 小时 11 分（`net.ipv4.tcp_keepalive_time + net.ipv4.tcp_keepalive_intvl * net.ipv4.tcp_keepalive_probes`）
    # 空连接攻击的最佳目标。攻击者把 IP 包头的源地址改成随机 IP，握完手就关 socket，用一台机发请求就能把你的哈希表填满
    local established_timeout=300
    local tcp_keepalive_time=$(yx_sysctl_config --read --key 'net.ipv4.tcp_keepalive_time')
    if [[ -n "${tcp_keepalive_time}" ]]  &&  [[ "${tcp_keepalive_time}" -lt "${established_timeout}" ]]; then
      established_timeout="${tcp_keepalive_time}"
    fi
    if ! yx_sysctl_config --write --key "net.netfilter.nf_conntrack_tcp_timeout_established" --val "${established_timeout}"; then
      echo_fatal "failed to change 'net.netfilter.nf_conntrack_tcp_timeout_established' to 300"
    fi

    # 类似，故意不发握手的 ACK 即可。但这个超时时间没那么夸张，系统也有 syn cookie 机制来缓解 syn flood 攻击。
    if ! yx_sysctl_config --write --key "net.netfilter.nf_conntrack_tcp_timeout_syn_recv" --val '5'; then
      echo_fatal "failed to change 'net.netfilter.nf_conntrack_tcp_timeout_syn_recv' to 5"
    fi
    if ! yx_sysctl_config --write --key "net.netfilter.nf_conntrack_tcp_timeout_syn_sent" --val '5'; then
      echo_fatal "failed to change 'net.netfilter.nf_conntrack_tcp_timeout_syn_sent' to 5"
    fi

    # 被动关闭方发 FIN 后如果一直收不到对面的 ACK 或 RST，会不断重发，
    # 直到超时才 CLOSE。`net.ipv4.tcp_retries2` 的默认值是 15，最多要等 924.6 秒……不过一般都会调小这个值。
    if ! yx_sysctl_config --write --key "net.netfilter.nf_conntrack_tcp_timeout_last_ack" --val '10'; then
      echo_fatal "failed to change 'net.netfilter.nf_conntrack_tcp_timeout_last_ack' to 10"
    fi
    


    ###############################
    # 变更生效
    ###############################
    # sysctl
    yx_sysctl_config --refresh
    


    # input_optional=$(iptables_default --list --input)

    local system=$(linux_type)
    if [[ ${system} == "centos" || ${system} == "debian" ]]; then
      echo_verbose 'Save iptables rule ...'
      echo_cmd "service iptables save"

      echo_verbose 'Restart iptables services...'
      echo_cmd "service iptables stop"
      echo_cmd "service iptables start"
    elif [[ ${system} == "ubuntu" ]]; then

      echo_verbose 'Save iptables rule ...'
      
      local tmp_path=$(mktemp --directory)
      if [ -z "${tmp_path}" ]; then
        echo_fatal "Failed to create a temp directory"
      fi

      local iptables_dump_file="${tmp_path}/iptables"
      echo_cmd "${IPTABLES_SAVE} --file ${iptables_dump_file}"
      if [[ $? != 0 ]]; then
        echo_fatal "Failed to dump iptables' rule"
      fi

      local ip6tables_dump_file="${tmp_path}/ip6tables"
      echo_cmd "${IP6TABLES_SAVE} --file ${ip6tables_dump_file}"
      if [[ $? != 0 ]]; then
        echo_fatal "Failed to dump ip6tables' rule"
      fi


      # Save iptables' dump file and create systemd service restore the dump at launch.
      save_iptabls_dump --iptables-dump "${iptables_dump_file}" --ip6tables-dump "${ip6tables_dump_file}"

      
    else
      :
    fi

  fi

}

function iptables_clear()
{
  local show_help=false
  local info_level=

  while [ $# -gt 0 ]; do
		case $1 in

      --info-level )
        shift
        info_level=$1
        ;;

      --help )
        show_help=true
      ;;

      *)
        echo_fatal "Invalid optional ${1}, try '-h' or '--help' to show more information"
        exit 1
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_clear
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    echo_cmd "${IPTABLES} -F"
    echo_cmd "${IPTABLES} -X"
    echo_cmd "${IPTABLES} -Z"
    echo_cmd "${IPTABLES} -t nat -F"
    echo_cmd "${IPTABLES} -t nat -X"
    echo_cmd "${IPTABLES} -t nat -Z"

    echo_cmd "${IP6TABLES} -F"
    echo_cmd "${IP6TABLES} -X"
    echo_cmd "${IP6TABLES} -Z"
    echo_cmd "${IP6TABLES} -t nat -F"
    echo_cmd "${IP6TABLES} -t nat -X"
    echo_cmd "${IP6TABLES} -t nat -Z"
  fi

}

function iptables_default()
{
  local opt_input=false
  local opt_output=false
  local opt_forward=false

  local show=false

  local show_help=false
  local info_level=

  local option=$1
  if strcontains "${option}" 'Enable Accept Allow' --ignorecase; then
    option="ACCEPT"
    shift
  elif strcontains "${option}" 'Disable Drop Block' --ignorecase; then
    option="DROP"
    shift
  else
    option=
  fi



  while [ $# -gt 0 ]; do
		case $1 in
			--input )
        opt_input=true
			;;

			--output )
        opt_output=true
			;;

			--forward )
        opt_forward=true
      ;;

			--all )
        opt_input=true
        opt_output=true
        opt_forward=true
			;;

			--list )
        show=true
      ;;

      --info-level )
        shift
        info_level=$1
      ;;


			-h | --help )
        show_help=true
			;;

			*)
        echo_fatal "Invalid optional ${1}, try '-h' or '--help' to show more information"
				exit 1
				;;
		esac
		shift
	done


  if ${show_help}; then
    usage_default
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi


    if ! ${show}; then
    
      if [ -z ${option} ]; then
        echo_fatal 'iptables default need at least one params [DROP , ACCEPT]'
      fi

      if ${opt_input}; then
        echo_cmd "${IPTABLES} -P INPUT ${option}"
      fi

      if ${opt_output}; then
        echo_cmd "${IPTABLES} -P OUTPUT ${option}"
      fi

      if ${opt_forward}; then
        echo_cmd "${IPTABLES} -P FORWARD ${option}"
      fi

      # always drop ipv6
      echo_cmd "${IP6TABLES} -P INPUT DROP"
      echo_cmd "${IP6TABLES} -P OUTPUT DROP"
      echo_cmd "${IP6TABLES} -P FORWARD DROP"
    else

      if ${opt_input}; then
        #:echo_cmd
        "${IPTABLES}" -L INPUT -nv | head --lines 1 | awk '{print $4}' | grep -o "[^ ]\+\( \+[^ ]\+\)*"
      fi

      if ${opt_output}; then
        #:echo_cmd
        "${IPTABLES}" -L OUTPUT -nv | head --lines 1 | awk '{print $4}' | grep -o "[^ ]\+\( \+[^ ]\+\)*"
      fi

      if ${opt_forward}; then
        #:echo_cmd
        "${IPTABLES}" -L FORWARD -nv | head --lines 1 | awk '{print $4}' | grep -o "[^ ]\+\( \+[^ ]\+\)*"
      fi
    fi
  fi





}


function iptables_wrapper()
{

  local chain=

  local interface_in=
  local interface_out=
  local not_interface_in=
  local not_interface_out=

  #local protocol='all' #default protocol
  local protocol=
  local protocol_flag=

  local mac=
  local not_mac=

  local ip_from=
  local ip_to=
  local not_ip_from=
  local not_ip_to=

  local port_from=
  local port_to=

  local fragment=
  local not_fragment=

  local state=

  # local limitstr=
  local -a limitstr_array
  local logstr=


  local info_level=
  local show=false

  local show_help=false

  local additional=

  local option=$1
  if ! [[ "${option}" =~ ^-.*$ ]]; then
    shift

    if strcontains "${option}" 'Enable Accept Allow' --ignorecase; then
      option="ACCEPT"
    elif strcontains "${option}" 'Disable Drop Block' --ignorecase; then
      option="DROP"
    elif strcontains "${option}" 'Return' --ignorecase; then
      option="RETURN"
    elif strcontains "${option}" 'Log' --ignorecase; then
      option="LOG"
    elif strcontains "${option}" 'Reject' --ignorecase; then
      option="REJECT"
    elif strcontains "${option}" 'Reject-with' --ignorecase; then
      option="REJECT"
      local reject_value=$1
      if ! [[ "${reject_value}" =~ ^-.*$ ]]; then
        shift
        option="${option} --reject-with ${reject_value}"
      fi
    else
      : # custom option
    fi

  else
    option=
  fi



  local cursor=
	while [ $# -gt 0 ]; do

		case $1 in

			--chain )
        cursor=$1
				shift
				chain=$1
			;;

      --fragment )
        cursor=$1
        fragment=$1
      ;;

      --not-fragment )
        cursor=$1
        not_fragment=$1
      ;;

      --interface-in )
        cursor=$1
				shift
        interface_in=$1
			;;

      --interface-out )
        cursor=$1
				shift
        interface_out=$1
			;;

      --not-interface-in )
        cursor=$1
				shift
        not_interface_in=$1
			;;

      --not-interface-out )
        cursor=$1
				shift
        not_interface_out=$1
			;;

			--proto )
        cursor=$1
				shift
				protocol=$1
			;;

			--proto-flag )
        cursor=$1
				shift
        protocol_flag=$1
			;;

      --mac )
        cursor=$1
				shift
        mac=$1
      ;;

      --notmac )
        cursor=$1
				shift
        not_mac=$1
      ;;

      --ip-from )
        cursor=$1
				shift
        ip_from=$1
      ;;

      --not-ip-from )
        cursor=$1
				shift
        not_ip_from=$1
      ;;

      --ip-to )
        cursor=$1
				shift
        ip_to=$1
      ;;

      --not-ip-to )
        cursor=$1
				shift
        not_ip_to=$1
      ;;

      --port-from )
        cursor=$1
				shift
        port_from=$1
      ;;

      --port-to )
        cursor=$1
				shift
        port_to=$1
      ;;

      --limit )
        cursor=$1
				shift
        limitstr_array=("${limitstr_array[@]}" "${1}")
      ;;

      --state )
        cursor=$1
        shift
        state=$1
      ;;

      --list )
        cursor=$1
        show=true
      ;;

      --log )
        cursor=$1
        shift
        logstr=$1
			;;

      --info-level )
        cursor=$1
        shift
        info_level=$1
      ;;

      --help )
        cursor=$1
        show_help=true
      ;;

			*)
        if [[ "${cursor}" == '--proto' ]] && [[ "${protocol}" == 'tcp' || "${protocol}" == 'tcp !' ]] && [ $1 == '--syn' ]; then
          protocol="${protocol} $1"
        elif [[ "${cursor}" == '--proto' ]] && [ "${protocol}" == 'tcp' ] && [ $1 == '!' ]; then
          protocol="${protocol} $1"
        elif [[ "${cursor}" == '--proto-flag' ]]; then
          protocol_flag="${protocol_flag} $1"
        else
          cursor='<additional>' # special cursor for additional params
          additional="${additional} $1"
        fi
				;;
		esac
		shift
	done



  if ${show_help}; then
    usage_filter
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    if ${show}; then
      local chain_params=
      if [ -n "${chain}" ]; then
        chain_params="${chain}"
      fi

      echo_cmd "${IPTABLES} -nvL ${chain_params}"
      exit 0
    else

      # if [ -z "${option}" ]; then
      #   echo_fatal 'iptables filter need at least one params [DROP , ACCEPT]'
      # fi

      # chain
      if [ -n "${chain}" ]; then


        if strcontains "${chain}" 'input' --ignorecase; then
          chain='INPUT'
        elif strcontains "${chain}" 'output' --ignorecase; then
          chain='OUTPUT'
        else
          :
          # for custom chain
          # chain=$(echo "${chain}" | tr '[:lower:]' '[:upper:]')
        fi
      else
        echo_fatal "Must indicate --chain [chain]"
      fi

      # fragment
      local fragment_params=''
      if [[ -n "${fragment}" ]] && [[ -z "${not_fragment}" ]]; then
        fragment_params="${fragment_params} --fragment"
      elif [[ -z "${fragment}" ]] && [[ -n "${not_fragment}" ]]; then
        fragment_params="${fragment_params} ! --fragment"
      elif [[ -n "${fragment}" ]] && [[ -n "${not_fragment}" ]]; then
        echo_fatal "You should not set --fragment and --not-fragment at same time"
      fi

      # interface
      local interface_params=''
      if [[ -n "${interface_in}" ]] || [[ -n "${interface_out}" ]] || [[ -n "${not_interface_in}" ]] || [[ -n "${not_interface_out}" ]]; then
        if [[ -n "${interface_in}" ]]; then
          interface_params="${interface_params} -i ${interface_in}"
        elif [[ -n "${not_interface_in}" ]]; then
          interface_params="${interface_params} ! -i ${not_interface_in}"
        fi

        if [[ -n "${interface_out}" ]]; then
          interface_params="${interface_params} -o ${interface_out}"
        elif [[ -n "${not_interface_out}" ]]; then
          interface_params="${interface_params} ! -o ${not_interface_out}"
        fi

      fi

      # protocol
      local protocol_params=''
      if [[ -n ${protocol} ]]; then
        protocol_params="${protocol_params} -p ${protocol}"

        if [[ -n "${protocol_flag}" ]]; then
          if [[ "${protocol}" == "icmp" ]]; then
            protocol_params="${protocol_params} --icmp-type ${protocol_flag}"
          elif [[ "${protocol}" == "tcp" ]]; then
            protocol_params="${protocol_params} --tcp-flags ${protocol_flag}"
          else
            echo_fatal "Unknown flag ${protocol_flag} for protocol ${protocol}"
          fi
        fi
      fi

      # mac
      local mac_params=''
      if [[ -n ${mac} ]]; then
        mac_params=" -m mac --mac-source ${mac}"
      elif [[ -n ${not_mac} ]]; then
        mac_params=" -m mac ! --mac-source ${not_mac}"
      fi

      #indicate ip-address or net-segment
      local ip_params=''
      if [[ -n "${ip_from}" ]] || [[ -n "${not_ip_from}" ]] || [[ -n "${ip_to}" ]] || [[ -n "${not_ip_to}" ]]; then
        # ip_params=' -m iprange'

        if [[ -n ${ip_from} ]]; then
          if yx_str_checkfmt '^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}(/[0-3]?[0-9])?$' "${ip_from}"; then
            ip_params="${ip_params} -s ${ip_from}"
          elif yx_str_checkfmt '^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}-([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}$' "${ip_from}"; then
            ip_params="${ip_params} -m iprange --src-range ${ip_from}"
          else
            echo_fatal "\"${ip_from}\" is not a valid ip-address or net-setment on --ip-from"
          fi
        elif [[ -n ${not_ip_from} ]]; then
          if yx_str_checkfmt '^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}(/[0-3]?[0-9])?$' "${not_ip_from}"; then
            ip_params="${ip_params} ! -s ${not_ip_from}"
          elif yx_str_checkfmt '^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}-([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}$' "${not_ip_from}"; then
            ip_params="${ip_params} -m iprange ! --src-range ${not_ip_from}"
          else
            echo_fatal "\"${not_ip_from}\" is not a valid ip-address or net-setment on --not-ip-from"
          fi
        fi

        if [[ -n ${ip_to} ]]; then
          if yx_str_checkfmt '^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}(/[0-3]?[0-9])?$' "${ip_to}"; then
            ip_params="${ip_params} -d ${ip_to}"
          elif yx_str_checkfmt '^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}-([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}$' "${ip_to}"; then
            ip_params="${ip_params} -m iprange --dst-range ${ip_to}"
          else
            echo_fatal "\"${ip_to}\" is not a valid ip-address or net-setment on --ip-to"
          fi
        elif [[ -n ${not_ip_to} ]]; then
          if yx_str_checkfmt '^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}(/[0-3]?[0-9])?$' "${not_ip_to}"; then
            ip_params="${ip_params} ! -d ${not_ip_to}"
          elif yx_str_checkfmt '^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}-([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}$' "${not_ip_to}"; then
            ip_params="${ip_params} -m iprange ! --dst-range ${not_ip_to}"
          else
            echo_fatal "\"${not_ip_to}\" is not a valid ip-address or net-setment on --not-ip-to"
          fi
        fi

      fi

      # port
      local port_params=''
      if [ -n "${port_from}" ] || [ -n "${port_to}" ]; then
        port_params=' -m multiport'
        if [ -n "${port_from}" ]; then
          port_params="${port_params} --sports ${port_from}"
        fi

        if [ -n "${port_to}" ]; then
          port_params="${port_params} --dports ${port_to}"
        fi
      fi

      #-m limit params
      local limit_params=
      for limitstr in "${limitstr_array[@]}"; do
        if [ -n "${limitstr}" ]; then
          # local limit=$(echo ${limitstr} | awk 'BEGIN{FS=":"}{print $1}')
          # local burst=$(echo ${limitstr} | awk 'BEGIN{FS=":"}{print $2}')
          # limit_params=$(_parse_limit "${limit}" "${burst}")
          # _parse_limit2 "${limitstr}"
          limit_params="${limit_params}$(_parse_limit2 ${limitstr})"
        fi
      done



      # state
      local state_params=''
      if [ -n "${state}" ]; then
        state_params=" -m state --state ${state}"
      fi

      # option
      local option_params=''
      if [ -n "${option}" ]; then
        option_params=" -j ${option}"
      fi

      if [ -n "${chain}" ]; then
        if ! iptables_chain exist --name "${chain}"; then
          iptables_chain create --name "${chain}"
        fi
      fi

      if [ -n "${logstr}" ]; then
        
        local log_limit_params=''
        local log_prefix=$(echo "${logstr}" | awk 'BEGIN{FS=":"}{print $1}')

        if [ -n "${log_prefix}" ]; then
          local log_limitstr=${logstr#"${log_prefix}":}
          if [ -n "${log_limitstr}" ]; then
            if [ "${log_limitstr}" == '-' ] && [ -n "${limit_params}" ]; then
              log_limit_params="${limit_params}"
            else
              log_limit_params=$(_parse_limit2 "${log_limitstr}")
            fi
          fi
        fi

        if [ -n "${log_prefix}" ]; then
          # 有log参数，则记录log
          echo_cmd "${IPTABLES} -A ${chain}${fragment_params}${interface_params}${protocol_params}${mac_params}${ip_params}${port_params}${state_params}${log_limit_params} -j LOG --log-prefix ${log_prefix}:${additional}"
        fi
      fi

      if [[ ${option} != "LOG" ]]; then
        # 如果option 已经是log, 则不再额外执行其他逻辑
        echo_cmd "${IPTABLES} -A ${chain}${fragment_params}${interface_params}${protocol_params}${mac_params}${ip_params}${port_params}${state_params}${limit_params}${option_params}${additional}"
      fi

    fi # end of if ${show};

  fi # end of if ${show_help}

}


function iptables_filter()
{

  local info_level=

  local show_help=false

  local chain=
  local additional=

  local option=$1
  if ! [[ "${option}" =~ ^-.*$ ]]; then
    shift
  else
    option=
  fi

  # if [[ ${option} == 'enable' ]] || [[ ${option} == 'accept' ]] || [[ ${option} == 'ACCEPT' ]] ; then
  #   option="ACCEPT"
  #   shift
  # elif [[ ${option} == 'disable' ]] || [[ ${option} == 'drop' ]] || [[ ${option} == 'DROP' ]]; then
  #   option="DROP"
  #   shift
  # else
  #   option=
  # fi


	while [ $# -gt 0 ]; do
		case $1 in

      --chain )
        shift
        chain=$1
      ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --help )
        show_help=true
      ;;

			*)
        additional="${additional} $1"
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_filter
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi


    if [ -z "${option}" ]; then
      echo_fatal 'iptables filter need at least one params [DROP , ACCEPT]'
    fi

    local chain_params=
    if [ -n "${chain}" ]; then
      chain_params="--chain ${chain}"
    fi

    echo_verbose 'Add filter rule...'
    iptables_wrapper "${option}" ${chain_params} ${additional}
  fi

}





function iptables_handle_protocol()
{

  local type=
  local protocol_name=
  local additional=

  local option=$1
  if ! [[ "${option}" =~ ^-.*$ ]]; then
    shift
  else
    option=
  fi


	while [ $# -gt 0 ]; do
		case $1 in

      --type )
				shift
        type=$1
			;;

      --proto-name )
				shift
				protocol_name=$1
			;;

			*)
        additional="${additional} $1"
      ;;
		esac
		shift
	done


  if [ -n "${protocol_name}" ] && [ -n "${type}" ]; then
    local handle_func=$(search_handler_info "${protocol_name}" "${type}")
    if [ -n "${handle_func}" ]; then
      echo_verbose "Use handler ${handle_func}(protocol=${hook_protocol_name} type=${type} option=${option})"
      ${handle_func} ${option} --type ${type} ${additional}
      return $?
    fi
  fi

  if [[ ${protocol_name} =~ ^wall-.*$ ]]; then
    # If no handle registed on native(wall-*), ignore the following operation.
    echo_fatal "Can not find a native-handle '${protocol_name}' on '${type}'"
    return 0
  fi


  return 1
}


function iptables_wall()
{
  local chain=

  local interface=
  local not_interface=
  local force_ip=false
  local ip=
  local not_ip=
  local port=
  local net=

  local protocol=
  local protocol_flag=

  local -a limitstr_array
  local logstr=

  local info_level=

  local additional=
  local show_help=false

  local type=$1
  if ! [[ "${type}" =~ ^-.*$ ]]; then
    shift

    if strcontains "${type}" 'server srv' --ignorecase; then
      type="server"
    elif strcontains "${type}" 'client clt' --ignorecase; then
      type="client"
    elif strcontains "${type}" 'incoming' --ignorecase; then
      type="incoming"
    elif strcontains "${type}" 'outgoing' --ignorecase; then
      type="outgoing"
    else
      echo_fatal "${CMD} wall unknown operation-type: ${type}"
    fi

    local option=$1
    if ! [[ "${option}" =~ ^-.*$ ]]; then
      shift
      if strcontains "${option}" 'Reject-with' --ignorecase; then
        option="REJECT"
        local reject_value=$1
        if ! [[ "${reject_value}" =~ ^-.*$ ]]; then
          shift
          option="${option} --reject-with ${reject_value}"
        fi
      fi
    else
      option=
    fi
  
  else
    type=
  fi

      # --log )
      #   shift
	    #   log=true
      #   log_prefix=$1
			# ;;

  local cursor=
	while [ $# -gt 0 ]; do
    
		case $1 in

      --chain )
        cursor=$1
				shift
        chain=$1
			;;

      --interface )
        cursor=$1
				shift
        interface=$1
			;;

      --not-interface )
        cursor=$1
				shift
        not_interface=$1
			;;

      --force-ip )
        cursor=$1
				shift
        force_ip=true
			;;

      --ip )
        cursor=$1
				shift
        ip=$1
			;;

      --not-ip )
        cursor=$1
				shift
        not_ip=$1
			;;
      
      --net )
        cursor=$1
				shift
        net=$1
			;;

      --port )
        cursor=$1
				shift
        port=$1
			;;

      --proto )
        cursor=$1
				shift
				protocol=$1
			;;

			--proto-flag )
        cursor=$1
				shift
        protocol_flag=$1
			;;

      --limit )
        cursor=$1
				shift
        limitstr_array=("${limitstr_array[@]}" "${1}")
      ;;

      --log )
        cursor=$1
				shift
				logstr=$1
			;;

      --info-level )
        cursor=$1
        shift
        info_level=$1
      ;;

      --help )
        cursor=$1
        show_help=true
      ;;

      ####################
      # block optional for iptables_filter 
      ####################
      --interface-in )
        cursor=$1
				shift
        echo_fatal "Can not use ${cursor} with ${CMD} wall"
			;;

      --interface-out )
        cursor=$1
				shift
        echo_fatal "Can not use ${cursor} with ${CMD} wall"
			;;

      --not-interface-in )
        cursor=$1
				shift
        echo_fatal "Can not use ${cursor} with ${CMD} wall"
			;;

      --not-interface-out )
        cursor=$1
				shift
        echo_fatal "Can not use ${cursor} with ${CMD} wall"
			;;

      --ip-from )
        cursor=$1
				shift
        echo_fatal "Can not use ${cursor} with ${CMD} wall"
      ;;

      --not-ip-from )
        cursor=$1
				shift
        echo_fatal "Can not use ${cursor} with ${CMD} wall"
      ;;

      --ip-to )
        cursor=$1
				shift
        echo_fatal "Can not use ${cursor} with ${CMD} wall"
      ;;

      --not-ip-to )
        cursor=$1
				shift
        echo_fatal "Can not use ${cursor} with ${CMD} wall"
      ;;

      --port-from )
        cursor=$1
				shift
        echo_fatal "Can not use ${cursor} with ${CMD} wall"
      ;;

      --port-to )
        cursor=$1
				shift
        echo_fatal "Can not use ${cursor} with ${CMD} wall"
      ;;

      ####################
      # For additional params
      ####################
			*)
        if [[ "${cursor}" == '--proto' ]] && [ "${protocol}" == 'tcp' ] && [ $1 == '--syn' ]; then
          protocol="${protocol} $1"
        elif [[ "${cursor}" == '--proto-flag' ]]; then
          protocol_flag="${protocol_flag} $1"
        else
          cursor='<additional>' # special cursor for additional params
          additional="${additional} $1"
        fi
				;;
		esac
		shift
	done



  if ${show_help}; then
    usage_wall
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi


    if [ -z ${type} ]; then
      echo_fatal "Type must not be nil. ${CMD} wall <type> <optional>. try '-h' or '--help' to show more information."
    fi

    # if [ -z "${option}" ]; then
    #   echo_fatal "Optional must not be nil. ${CMD} wall <type> <optional>. try '-h' or '--help' to show more information."
    # fi


    # chain params
    local chain_in=INPUT
    local chain_out=OUTPUT
    if [ -n "${chain}" ]; then
      if strcontains "${chain}" 'INPUT OUTPUT FORWARD PREROUTING POSTROUTING ACCEPT DROP REJECT RETURN' --ignorecase; then
        echo_fatal "Can not use chain with name '${chain}'. "
      else
        chain_in="${chain}"_in
        chain_out="${chain}"_out
      fi
    fi


    local -a inter_list
    local -a ip_list
    # inter_list=(\*)
    # ip_list=(\*)


    function _wall_handle_inter()
    {
      local local_interface=$1

      # Find all interface
      if [[ ${local_interface} == '*' ]]; then

        if which ip > /dev/null; then
            inter_str=$(ip link show | awk -F': ' '/^[0-9]+: /{print $2}' | tr '[:space:]' ' ' | tr -s '[:space:]' | grep -o "[^ ]\+\( \+[^ ]\+\)*" )
        else
            inter_str=$(ifconfig -a | grep -o '^[a-zA-Z0-9]*' | tr '[:space:]' ' ' | tr -s '[:space:]' | grep -o "[^ ]\+\( \+[^ ]\+\)*" )
        fi


        local tmp_inter_list=()
        read -r -a tmp_inter_list <<< "${inter_str}"
        for inter in "${tmp_inter_list[@]}"; do

            # '*' not include local-address
            if [[ "${inter}" =~ ^lo[0-9]*$ ]]; then
              continue
            fi

            # exclude '--not-interface' if it exist
            if [[ -n "${not_interface}" ]]  &&  [[ "${inter}" == "${not_interface}" ]]; then
              continue
            fi

            if ${force_ip}; then
              
              # convert interface to ip/mask
              local ip_addr=$(ip_from_inter "${inter}" )
              if [ -n "${ip_addr}" ]; then

                # exclude '--ip' if it exist
                if [[ -n "${ip}" ]] && [[ "${ip}" == "${ip_addr}" ]]; then
                  continue
                fi
                
                # exclude '--not-ip' if it exist
                if [[ -n "${not_ip}" ]] && [[ "${not_ip}" == "${ip_addr}" ]]; then
                  continue
                fi

                ip_list=("${ip_list[@]}" "${ip_addr}");
              fi
            else
              inter_list=("${inter_list[@]}" "${inter}");
            fi
        done
      else

        if ${force_ip}; then
          # convert ip-address to ip/mask
          local ip_addr=$(ip_from_inter "${local_interface}" )
          if [ -n "${ip_addr}" ]; then

            # exclude '--ip' if it exist
            # exclude '--not-ip' if it exist
            if [[ "${ip_addr}" != "${ip}" ]] && [[ "${ip_addr}" != "${not_ip}" ]]; then
              ip_list=("${ip_list[@]}" "${ip_addr}");
            fi

          fi
        else
          inter_list=("${inter_list[@]}" "${local_interface}");
        fi

      fi
    }

    function _wall_handle_ip()
    {
      local local_ip=$1

      if [ -n "${local_ip}" ]; then
        ip_list=("${ip_list[*]}" "${local_ip}");
      fi
    }

    _wall_handle_inter "${interface}"
    _wall_handle_ip "${ip}"


    if [[ -n ${net} ]]; then
      if yx_str_checkfmt '^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}(/[0-3]?[0-9])?$' "${net}"; then
        _wall_handle_ip "${net}"
      elif yx_str_checkfmt '^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}-([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}$' "${net}"; then
        _wall_handle_ip "${net}"
      else
        _wall_handle_inter "${net}"
      fi
    fi


    # Add * to empty list
    inter_list=($(printf "%s\n" "${inter_list[@]}" | sort -u | tr '\n' ' '))
    # inter_list=($(awk -v RS=' ' '!a[$1]++' <<< ${inter_list[@]}))
    if [ ${#inter_list[@]} -eq 0 ]; then
      inter_list=("${inter_list[@]}" \*);
    fi

    ip_list=($(printf "%s\n" "${ip_list[@]}" | sort -u | tr '\n' ' '))
    # ip_list=($(awk -v RS=' ' '!a[$1]++' <<< ${ip_list[@]}))
    if [ ${#ip_list[@]} -eq 0 ]; then
      ip_list=("${ip_list[@]}" \*)
    fi


    # --protocol-name params for `iptables_handle_protocol` only
    ####################
    local hook_protocol_name=
    if [ -n "${protocol}" ]; then
      hook_protocol_name="--proto-name $(echo "${protocol}" | awk '{print $1}' | tr '[:upper:]' '[:lower:]' | grep -o "[^ ]\+\( \+[^ ]\+\)*")"
    fi


    # try tanslate the port number from protocol name.
    # try get a real protocol name.
    ####################
    if [ -z "${port}" ] && [ -n "${protocol}" ]; then

      #try get port number and low-level protocol name from rule config
      if [ -z "${port}" ]; then
        port=$(iptables_config "rule.${protocol}" --read --key port)
        if [ -n "${port}" ]; then
          protocol=$(iptables_config "rule.${protocol}" --read --key protocol)
          if [ -z "${protocol}" ]; then
            protocol='tcp'
          fi
        fi
      fi

      #try get port number and low-level protocol name from registed hook handler
      if [ -z "${port}" ]; then
        port=$(search_handler_info "${protocol}" port)
        if [ -n "${port}" ]; then
          protocol=$(search_handler_info "${protocol}" protocol) # e.g. http->tcp
          if [ -z "${protocol}" ]; then
            protocol='tcp'
          fi
        fi
      fi

      #try get port number from DEFAULT_PORT
      if [ -z "${port}" ]; then
        port=${DEFAULT_PORT[${protocol^^}]} # Use protocol number to get port number
        if [ -n "${port}" ]; then
          protocol='tcp'
        fi
      fi

    fi


    # protocol params
    local protocol_params=
    if [ -n "${protocol}" ]; then
      protocol_params="${protocol_params} --proto ${protocol}"
    fi
    if [ -n "${protocol_flag}" ]; then
      protocol_params="${protocol_params} --proto-flag ${protocol_flag}"
    fi


    # limit params
    local limit_params=
    for limitstr in "${limitstr_array[@]}"; do
      if [ -n "${limitstr}" ]; then
        limit_params="${limit_params} --limit ${limitstr}"
      fi
    done


    # log params
    local log_params=''
    if [ -n "${logstr}" ]; then
      log_params="${log_params} --log ${logstr}"
    fi



    for inter_in_list in "${inter_list[@]}"; do
      for ip_in_list in "${ip_list[@]}"; do

        local hook_params=''

        # hook inter
        if [ -n "${inter_in_list}" ] && [ "${inter_in_list}" != '*' ]; then
          hook_params="${hook_params} --interface ${inter_in_list}"
        fi
        if [ -n "${not_interface}" ]; then
          hook_params="${hook_params} --not-interface ${not_interface}"
        fi
        
        # hook ip
        if [ -n "${ip_in_list}" ] && [ "${ip_in_list}" != '*' ]; then
          hook_params="${hook_params} --ip ${ip_in_list}"
        fi
        if [ -n "${not_ip}" ]; then
          hook_params="${hook_params} --not-ip ${not_ip}"
        fi
        
        # hook port
        if [ -n "${port}" ]; then
          hook_params="${hook_params} --port ${port}"
        fi

        # hook chain 
        if [ -n "${chain}" ]; then
          hook_params="${hook_params} --chain ${chain}"
        fi



        if ! iptables_handle_protocol ${option} --type ${type} ${hook_protocol_name} ${protocol_params} ${hook_params} ${limit_params} ${log_params} ${additional}; then

          local in_params=''
          local out_params=''

          echo_verbose "Use common handler ${type}(protocol=${hook_protocol_name} option=${option})"

          # interface
          if [[ -n "${inter_in_list}" ]] && [[ "${inter_in_list}" != '*' ]]; then
            in_params="${in_params} --interface-in ${inter_in_list}"
            out_params="${out_params} --interface-out ${inter_in_list}"
          fi
          if [ -n "${not_interface}" ]; then
            in_params="${in_params} --not-interface-in ${not_interface}"
            out_params="${out_params} --not-interface-out ${not_interface}"
          fi

          # ip
          if [[ -n "${ip_in_list}" ]] && [[ "${ip_in_list}" != '*' ]]; then
              in_params="${in_params} --ip-from ${ip_in_list}"
              out_params="${out_params} --ip-to ${ip_in_list}"
          fi
          if [ -n "${not_ip}" ]; then
              in_params="${in_params} --not-ip-from ${not_ip}"
              out_params="${out_params} --not-ip-to ${not_ip}"
          fi


          if [[ "${type}" == 'server' ]]; then

            if [ -n "${port}" ]; then
              in_params="${in_params} --port-to ${port}"
              out_params="${out_params} --port-from ${port}"
            fi

            echo_verbose 'Add server chain...'
            iptables_wrapper ${option} --chain ${chain_in} ${in_params} ${protocol_params} ${limit_params} --state NEW,ESTABLISHED ${log_params} ${additional}
            iptables_wrapper ${option} --chain ${chain_out} ${out_params} ${protocol_params} ${limit_params} --state ESTABLISHED ${log_params} ${additional}

            if [ -n "${chain}" ]; then
              iptables_wrapper ${chain_in} --chain INPUT ${in_params} ${protocol_params}
              iptables_wrapper ${chain_out} --chain OUTPUT ${out_params} ${protocol_params}
            fi

          elif [[ ${type} == 'client' ]]; then

            if [ -n "${port}" ]; then
              in_params="${in_params} --port-from ${port}"
              out_params="${out_params} --port-to ${port}"
            fi

            echo_verbose 'Add client chain...'
            iptables_wrapper ${option} --chain ${chain_out} ${out_params} ${protocol_params} ${limit_params} --state NEW,ESTABLISHED ${log_params} ${additional}
            iptables_wrapper ${option} --chain ${chain_in} ${in_params} ${protocol_params} ${limit_params} --state ESTABLISHED ${log_params} ${additional}

            if [ -n "${chain}" ]; then
              iptables_wrapper "${chain_out}" --chain OUTPUT ${out_params} ${protocol_params} ${additional}
              iptables_wrapper "${chain_in}" --chain INPUT ${in_params} ${protocol_params} ${additional}
            fi


          elif [[ ${type} == 'incoming' ]]; then

            if [ -n "${port}" ]; then
              in_params="${in_params} --port-to ${port}"
            fi

            echo_verbose 'Add incoming chain...'
            iptables_wrapper "${option}" --chain ${chain_in} ${in_params} ${protocol_params} ${limit_params} ${log_params} ${additional}
          elif [[ ${type} == 'outgoing' ]]; then
            if [ -n "${port}" ]; then
              out_params="${out_params} --port-from ${port} --port-to ${port}"
            fi

            echo_verbose 'Add outgoing chain...'
            iptables_wrapper "${option}" --chain ${chain_out} ${out_params} ${protocol_params} ${limit_params} ${log_params} ${additional}

          fi # end of 'if [[ "${type}" =='

        fi
          
      done # end of 'for ip_in_list'
    done # end of 'for inter_in_list'
  fi
}

function iptables_srv()
{
  # local log=false  # TODO
  # local log_prefix=$1 # TODO

  local info_level=
  local show=false

  local show_help=false

  local option=$1
  if ! [[ "${option}" =~ ^-.*$ ]]; then
    shift
  else
    option=
  fi


  local cursor=
	while [ $# -gt 0 ]; do
    cursor=$1
		case $1 in

      # --log )
      #   shift
	    #   log=true
      #   log_prefix=$1
			# ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --help )
        show_help=true
      ;;

      ####################
      # For additional params
      ####################
			*)
        additional="${additional} $1"
				;;
		esac
		shift
	done


  if ${show_help}; then
    usage_wall
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    if ${show}; then
      echo_cmd "iptables -nvL"
      exit 0
    else

      if [ -z ${option} ]; then
        echo_fatal "Optional must not be nil. ${CMD} wall <optional>. try '-h' or '--help' to show more information."
      fi

      iptables_wall "${option}" --incoming ${additional}

    fi
  fi

}

function iptables_nat()
{

  local snat=false
  local dnat=false
  
  # lan
  local from_inter=

  # wan
  local to_inter=
  local log=false
  local log_prefix=

  local info_level=


	while [ $# -gt 0 ]; do
		case $1 in

			--snat )
				snat=true
			;;

			--dnat )
				dnat=true
			;;

			--from-inter )
				shift
				from_inter=$1
			;;

			--to-inter )
				shift
				to_inter=$1
			;;

			--log )
        shift
				log=true
        log_prefix=$1
			;;

      --info-level )
        shift
        info_level=$1
      ;;


			*)
        usage_nat
				exit
				;;
		esac
		shift
	done


  if ${snat}; then

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi


    if ${dnat}; then
      echo_fatal "Can not set both '--snat' and '--dnat' in one command"
    fi

    if [[ -z ${from_inter} ]]; then
      echo_fatal "Invalid --from-inter params"
    fi

    if [[ -z ${to_inter} ]]; then
      echo_fatal "Invalid --to-inter params"
    fi

    # set net.ipv4.ip_forward=1
    #echo "IP forwarding has been set to '1'"
    if ! yx_sysctl_config --write --refresh --key 'net.ipv4.ip_forward' --val 1 --refresh; then
    # if ! ip_forward_v4 enable; then
      echo_fatal "failed to change net.ipv4.ip_forward item to '1'"
    fi

    # 允许初始网络包转发
    if ${log}; then
      if [[ -z ${log_prefix} ]]; then
        log_prefix="${CMD}-Forward:"
      fi
      
      # Add forwarding log
      echo_verbose 'Add forwarding log...'
      echo_cmd "${IPTABLES} -A FORWARD -o ${to_inter} -i ${from_inter} -m conntrack --ctstate NEW -j LOG --log-prefix ${log_prefix} --log-level 4"
    fi

    # Add forwarding rule
    echo_verbose 'Add forwarding rule...'
    echo_cmd "${IPTABLES} -A FORWARD -o ${to_inter} -i ${from_inter} -m conntrack --ctstate NEW -j ACCEPT"
    # 允许已经建立链接的网络包转发
    #sudo iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
    echo_cmd "${IPTABLES} -A FORWARD -o ${to_inter} -i ${from_inter} -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT"
    echo_cmd "${IPTABLES} -A FORWARD -o ${from_inter} -i ${to_inter} -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT"

    # 设置SNAT
    # add SNAT rule
    echo_verbose 'add SNAT rule...'
    #iptables -t nat -A POSTROUTING -s 192.168.56.0/24 -j SNAT --to-source 10.0.2.15
    echo_cmd "${IPTABLES} -t nat -A POSTROUTING -o ${to_inter} -j MASQUERADE" # 这个记得之前应该好使啊????!!!!

    # 设置一个dnat, 强制DNS使用1.1.1.1
    #这个不需要设置
    #如果设置，客户端DNS的IP好像必须设置成一样的
    #sudo iptables -t nat -A PREROUTING -p udp --dport 53 -j DNAT --to 1.1.1.1

  elif ${dnat};then

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    echo_fatal 'not implement !!!'
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi
    echo_fatal "One of '--snat' or '--dnat' must be set."
  fi

}

function iptables_chain()
{
  local name=
  local table=
  local show_help=false
  local info_level=
  local custom_only=false
  local chain_io=false

  local -A common_tables
  common_tables=(
    [filter]='INPUT FORWARD OUTPUT'
    [nat]='PREROUTING POSTROUTING OUTPUT'
    [mangle]='PREROUTING POSTROUTING INPUT OUTPUT FORWARD'
    [raw]='PREROUTING OUTPUT'
  )


  local option=$1
  if strcontains "${option}" 'create' --ignorecase; then
    option="CREATE"
    shift
  elif strcontains "${option}" 'exist' --ignorecase; then
    option="EXIST"
    shift
  elif strcontains "${option}" 'remove' --ignorecase; then
    option="REMOVE"
    shift
  elif strcontains "${option}" 'list' --ignorecase; then
    option="LIST"
    shift
  else
    option=
  fi


  while [ $# -gt 0 ]; do
		case $1 in

			--table )
        shift
				table=$1
			;;

			--name )
        shift
				name=$1
			;;

      --custom-only )
				custom_only=true
			;;

      --chain-io )
				chain_io=true
			;;

      --info-level )
        shift
        info_level=$1
      ;;

      --help )
          show_help=true
      ;;


			*)
        additional="${additional} $1"
      ;;
		esac
		shift
	done

  if ${show_help}; then
    usage_chain
    exit 0
  else

    if [ -z "${table}" ]; then
      table="filter"
    fi

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    if [ -z ${option} ]; then
      echo_fatal 'iptables port need at least one params [Create , Exist, Remove, List]'
    fi

    if [[ "${option}" == 'CREATE' ]]; then
      if [ -z "${name}" ]; then
        echo_fatal "Must indicate a chain name with --name <name>"
      fi

      if ${chain_io}; then
        echo_verbose "Create new chain :'${name}_in'"
        echo_cmd "${IPTABLES} -N ${name}_in"

        echo_verbose "Create new chain :'${name}_out'"
        echo_cmd "${IPTABLES} -N ${name}_out"
      else
        echo_verbose "Create new chain :'${name}'"
        echo_cmd "${IPTABLES} -N ${name}"
      fi

      return $?
    elif [[ "${option}" == 'LIST' ]]; then
      # list common on specific table
      if ! ${custom_only}; then
        local common_chain_list_str=${common_tables["${table}"]}
        for common_chain in $(echo ${common_chain_list_str}); do
          echo ${common_chain}
        done
      fi

      # list all custom chain on specific table.
      local -A search_map
      for chain_str in $(${IPTABLES} -S | grep "\-N "); do
        if ! [[ ${chain_str} =~ ^\-N.*$ ]]; then

          if ${chain_io}; then

            # remove _in or _out sufix from chain_name
            local fix_chain_name=
            if [[ ${chain_str} =~ ^.*_in$ ]]; then
              fix_chain_name="${chain_str%_in}"
            elif [[ ${chain_str} =~ ^.*_out$ ]]; then
              fix_chain_name="${chain_str%_out}"
            else
              fix_chain_name="${chain_str}"
            fi

            # flag should not be exist
            if ! [[ -z "${fix_chain_name}" ]]  &&  [[ -z ${search_map["${fix_chain_name}"]} ]]; then

              local has_in=false
              local has_out=false

              # test whether <chain_name>_in or <chain_name>_out exist
              if iptables_chain exist --name "${fix_chain_name}_in"; then
                has_in=true
              fi
              if iptables_chain exist --name "${fix_chain_name}_out"; then
                has_out=true
              fi

              # record the flag
              search_map["${fix_chain_name}"]='1'

              # out put the chain_name
              if ${has_in} && ${has_out}; then
                echo "${fix_chain_name}(in,out)"
              elif ${has_in} && ! ${has_out}; then
                echo "${fix_chain_name}(in)"
              elif ! ${has_in} && ${has_out}; then
                echo "${fix_chain_name}(out)"
              elif ! ${has_in} && ! ${has_out}; then
                echo "${fix_chain_name}"
              fi

            fi # End of (if ! [[ -z "${fix_chain_name}" ]]  &&  [[ -z ${search_map["${fix_chain_name}"]} ]]; then)

          else
            echo "${chain_str}"
          fi # End of (if ${chain_io}; then)
          
        fi # End of (if ! [[ ${chain_str} =~ ^\-N.*$ ]]; then)
      done
      return $?
    elif [[ "${option}" == 'REMOVE' ]]; then
      
      function _remove_chain()
      {
        local name=$1

        if [ -z "${name}" ]; then
          echo_fatal "Chain name must not be empty, use --name to indicate a chain name. try '-h' or '--help' to show more information "
        fi

        local -a chain_list
        # add all chain on chan_list
        for custom_chain in $(iptables_chain list); do
          chain_list=(${chain_list[*]} ${custom_chain});
        done

        # walk through the chain list
        for chain in ${chain_list[*]}; do
          
          # ignore the delete chain
          if [[ "${chain}" == ${name} ]]; then
            continue
          fi

          # remove all reference of the chain from other tables.
          while true; do
            local line_num=$(${IPTABLES} -L ${chain} --line-numbers | grep -Ev "Chain .* \((policy .*|[0-9]* references)\)$" | grep -m 1 "${name}" | awk '{print $1}' | grep -o "[^ ]\+\( \+[^ ]\+\)*");
            if [ -z "${line_num}" ]; then
              break
            fi
            echo_cmd "${IPTABLES} -t ${table} -D ${chain} ${line_num}"
          done

        done

        # clear all contains of the chain
        echo_cmd "${IPTABLES} -t ${table} --flush ${name}"
        # delete the chain
        echo_cmd "${IPTABLES} -t ${table} --delete-chain ${name}"
      }

      if ! ${chain_io}; then
        _remove_chain "${name}"
      else
        local find_chain=false
        if iptables_chain exist --name "${name}_in"; then
          _remove_chain "${name}_in"
        fi

        if iptables_chain exist --name "${name}_out"; then
          _remove_chain "${name}_out"
        fi
      fi

      return $?
    elif [[ "${option}" == 'EXIST' ]]; then

      if [ -z "${name}" ]; then
        echo_fatal "Chain name must not be empty, use --name to indicate a chain name. try '-h' or '--help' to show more information "
      fi

      if strcontains "${name}" 'INPUT OUTPUT FORWARD PREROUTING POSTROUTING' --ignorecase; then
        return 0
      elif ${IPTABLES} -S | grep -q "\-N ${name}\W*$"; then
        return 0
      elif ${chain_io}; then
        if ${IPTABLES} -S | grep -q "\-N ${name}_in\W*$"; then
          echo ${IPTABLES} -S | grep -q "\-N ${name}_in\W*$"
          return 0
        elif ${IPTABLES} -S | grep -q "\-N ${name}_out\W*$"; then
          echo ${IPTABLES} -S | grep -q "\-N ${name}_out\W*$"
          return 0
        fi
      fi
    fi
  fi

  return 1
}


function iptables_loopback()
{

  local option=$1
  if strcontains "${option}" 'Accept Enable Allow' --ignorecase; then
    option="ACCEPT"
    shift
  elif strcontains "${option}" 'Drop Disable Block' --ignorecase; then
    option="DROP"
    shift
  else
    option=
  fi


  local additional=''

  # ignore params
  local interface=
  local not_interface=

  local show_help=false
  local info_level=

	while [ $# -gt 0 ]; do
		case $1 in

      --interface )
				shift
				interface=$1
			;;

			--not-interface )
				shift
				not_interface=$1
			;;

      --info-level )
        shift
        info_level=$1
        ;;

      --help )
        show_help=true
      ;;


			*)
        additional="${additional} $1"
      ;;
		esac
		shift
	done

  if ${show_help}; then
    usage_loopback
    exit 0
  else
     
    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    if [ -z ${option} ]; then
      echo_fatal 'iptables loopback need at least one params [DROP , ACCEPT]'
    fi

    if [[ -n ${interface} ]]; then
      echo_fatal "${CMD} loopback can not allow --interface interface"
    fi

    if [[ -n ${not_interface} ]]; then
      echo_fatal "${CMD} loopback can not support --not-interface params"
    fi

    iptables_wall incoming ${option} --interface lo+
    iptables_wall outgoing ${option} --interface lo+
  fi

}

function iptables_list()
{
  local table=
  local numberic=false
  local verbose=false
  local line_num=false
  local reference=false
  local chain_io=false

  local info_level=
  local show_help=false
  local additional=

  local chain=$1
  if ! [[ "${chain}" =~ ^-.*$ ]]; then
    shift
  else
    chain=
  fi

  while [ $# -gt 0 ]; do
		case $1 in

      --table )
        shift
        table=$1
      ;;

      --numeric )
        numberic=true
      ;;

      --verbose )
        verbose=true
      ;;

      --line-num )
        line_num=true
      ;;

      --chain-io )
				chain_io=true
			;;

      --reference )
				reference=true
			;;

      --info-level )
        shift
        info_level=$1
      ;;

      --help )
        show_help=true
      ;;

			*)
        additional="${additional} $1"
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_list
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    local params=''
    if [ -n "${table}" ]; then
      params="${params} --table ${table}"
    else
      params="${params} --table filter"
    fi
    if ${numberic}; then
      params="${params} --numeric"
    fi
    if ${verbose}; then
      params="${params} --verbose"
    fi

    if ${line_num}; then
      params="${params} --line-numbers"
    fi

    # use --list name
    # list 必须放在最后, 因为后面要拼 chain name
    params="${params} --list"

    # if display specific chain's info
    if [ -n "${chain}" ]; then

      # if should convert chain 'name' to 'name_in' and 'name_out'
      if ${chain_io}; then

        # display the chain
        if iptables_chain exist --name "${chain}_in"; then
          echo_cmd "${IPTABLES} ${params} ${chain}_in"
        fi
        if iptables_chain exist --name "${chain}_out"; then
          echo ""
          echo_cmd "${IPTABLES} ${params} ${chain}_out"
        fi

        # if need to display reference info
        if ${reference}; then

          # walk through all chain
          local -A search_map
          for chain_name in $(iptables_chain list); do
            
            # ignore the chain
            if [[ ${chain_name} == ${chain} ]]; then
              continue
            fi

            local has_ref=false
            # test whether chain_in exist
            if ${IPTABLES} -L "${chain_name}" | tail -n +3 | awk '{print $1}' | grep -q "${chain}_in"; then
              has_ref=true;
            fi
            # test whether chain_out exist
            if ${IPTABLES} -L "${chain_name}" | tail -n +3 | awk '{print $1}' | grep -q "${chain}_out"; then
              has_ref=true;
            fi

            # display
            if ${has_ref}; then
              echo ""
              ${IPTABLES} ${params} ${chain_name} | head -n 2 # header
              ${IPTABLES} ${params} ${chain_name} | tail -n +3 | grep "${chain}_in"  # in
              ${IPTABLES} ${params} ${chain_name} | tail -n +3 | grep "${chain}_out" #out
            fi

          done # End of (for chain_name in $(iptables_chain list); do)


        fi

      else # if ${chain_io}; then

        # display the chain
        echo_cmd "${IPTABLES} ${params} ${chain}"
        if [[ $? == 0 ]]; then
          # display all reference chain and rule
          for chain_name in $(iptables_chain list); do

            # ignore the chain
            if [[ ${chain_name} == ${chain} ]]; then
              continue
            fi

            # display all reference chain and rule
            if ${reference}; then
              if ${IPTABLES} -L "${chain_name}" | tail -n +3 | awk '{print $1}' | grep -Eq "^${chain}\W*$"; then
                echo ""
                ${IPTABLES} ${params} ${chain_name} | head -n 2
                ${IPTABLES} ${params} ${chain_name} | tail -n +3 | grep "${chain}"
              fi
            fi
          done
        else # End of (if [[ $? == 0 ]];)

          
          # list 命令到这里已经失败了, 下面是尝试给出更友善的错误提示。

          local -a searched_chain
          for test_chain in "${chain}_in" "${chain}_out"; do
            if iptables_chain exist --name "${test_chain}"; then
              searched_chain=(${searched_chain[@]} "${test_chain}")
            fi
          done

          if [[ ${#searched_chain[@]} != 0 ]]; then
          	local SAVEIFS=$IFS
            IFS=','
            local chain_list_str="${searched_chain[*]}"
            IFS=${SAVEIFS}

            echo_fatal "Incompatible chain name '${chain}'. There ares some similar names(${chain_list_str}), or you can add '--chain-io' to your list command"
          else
            echo_fatal "Incompatible chain name '${chain}'."
          fi

        fi

      fi # end of(if ${chain_io}; then)

    else
      # display all info
      ${IPTABLES} ${params}
    fi
  fi

}

function iptables_handler()
{
  # local handler=
  local retraction=

  local info_level=
  local show_help=false

  local option=$1
  if strcontains "${option}" 'list' --ignorecase; then
    option="LIST"
    shift
  else
    option=
  fi

  while [ $# -gt 0 ]; do
		case $1 in

      --retraction )
        shift
        retraction=$1
      ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --help )
        show_help=true
      ;;

			*)
        additional="${additional} $1"
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_handler
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    if [ -z ${option} ]; then
      echo_fatal 'iptables port need at least one params [List]'
    fi


    # echo "ff"
    if [[ "${option}" == 'LIST' ]]; then
      
      local indent=''
      if [ -n "${retraction}" ]; then
        local v=$(printf "%-${retraction}s" ' ')
        indent=$(echo "${v// /' '}")
      fi

      printf "%s%-10s  %-15s  %-6s  %-6s  %-30s\n" "${indent}" 'Name' 'Protocol' 'Server' 'Client' 'Description' 
      for protocol in $(list_handler_protocol); do
        # echo ${protocol}
        local name=$(search_handler_info "${protocol}" "name")
        local desc=$(search_handler_info "${protocol}" "desc")
        # local port=$(search_handler_info "${protocol}" "port")
        local real_proto=$(search_handler_info "${protocol}" "protocol")
        local srv_fun=$(search_handler_info "${protocol}" "server")
        local clt_fun=$(search_handler_info "${protocol}" "client")

        local srv_flag="NO"
        if [ -n "${srv_fun}" ]; then
          srv_flag="YES"
        fi

        local clt_flag="NO"
        if [ -n "${clt_fun}" ]; then
          clt_flag="YES"
        fi

        printf "%s%-10s  %-15s  %-6s  %-6s  %-30s\n" "${indent}" "${name}" "${protocol}" "${srv_flag}" "${clt_flag}" "${desc}"

      done

    fi


  fi
}


function iptables_storage()
{
  local path=
  local tmp_path=
  local forece=false

  local info_level=
  local show_help=false

  local option=$1
  if ! [[ "${option}" =~ ^-.*$ ]]; then
    shift
  else
    option=
  fi

  while [ $# -gt 0 ]; do
		case $1 in

      --path )
        shift
        path=$1
      ;;

      --force )
        force=true
      ;;

      --tmp-path )
        shift
        tmp_path=$1
      ;;

      --info-level )
        shift
        info_level=$1
      ;;

      --help )
        show_help=true
      ;;

			*)
        additional="${additional} $1"
      ;;
		esac
		shift
	done

  if ${show_help}; then
    usage_storage
    exit 0
  else
  
    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    if [ -z "${path}" ]; then
      echo_fatal "Path must not be empty, use --path to indicate a buckup path."
    fi

    # Create a temp directory
    if [ -n "${tmp_path}" ]; then
      if [ ! -d "${tmp_path}" ]; then
        echo_err "${tmp_path} does not exist, try to craete one."
        mkdir -p "${tmp_path}"
        if [ ! -d "${tmp_path}" ]; then
          echo_fatal "Failed to create the temp directory:${tmp_path}"
        fi
      fi
    else
      tmp_path=$(mktemp --directory)
      if [ -z "${tmp_path}" ]; then
        echo_fatal "Failed to create a temp directory"
      fi
    fi


    if strcontains "${option}" 'buckup' --ignorecase; then

      local tmp_tar_path="${tmp_path}/buckup"

      echo_verbose "Buckup iptables rule  ..."
      # save iptables rule and compress it
      local tmp_iptables_path="${tmp_path}/iptables"
      echo_cmd "${IPTABLES_SAVE} --file ${tmp_iptables_path}"
      if [[ $? != '0' ]]; then
        echo_fatal "Failed to save iptables's rules"
      else
        ${TAR} --create --absolute-names --file="${tmp_tar_path}" -C "${tmp_path}" "iptables"
      fi
      local tmp_ip6tables_path="${tmp_path}/ip6tables"
      echo_cmd "${IP6TABLES_SAVE} --file ${tmp_ip6tables_path}"
      if [[ $? != '0' ]]; then
        echo_fatal "Failed to save ip6tables's rules"
      else
        ${TAR} --append --absolute-names --file="${tmp_tar_path}" -C "${tmp_path}" "ip6tables"
      fi


      echo_verbose "Buckup net key in sysctl ..."
      #这里不用 `sysctl -p`, 是希望只备份网络相关配置。 
      local tmp_netfilter_config="${tmp_path}/net.conf"
      if [ "${NET_KEY_ARRAY}" ]; then
        for key in "${NET_KEY_ARRAY[@]}";
        do
          local val=$(yx_sysctl_config --read --key "${key}")
          if [ -n "${val}" ]; then
            yx_sysctl_config --write --file "${tmp_netfilter_config}" --key "${key}" --val "${val}"
          fi
        done
      fi
      if [ -f "${tmp_netfilter_config}" ]; then
        ${TAR} --append --absolute-names --file="${tmp_tar_path}" -C "${tmp_path}" "net.conf"
      fi


      echo_verbose "Buckup netfilter key in sysctl.config ..."
      #这里不用 `sysctl -p`, 是希望只备份网络相关配置。 
      local tmp_sysctl_config="${tmp_path}/netfilter.conf"
      if [ "${NETFILTER_KEY_ARRAY}" ]; then
        for key in "${NETFILTER_KEY_ARRAY[@]}";
        do
          local val=$(yx_sysctl_config --read --key "${key}")
          if [ -n "${val}" ]; then
            yx_sysctl_config --write --file "${tmp_sysctl_config}" --key "${key}" --val "${val}"
          fi
        done
      fi
      if [ -f "${tmp_sysctl_config}" ]; then
        ${TAR} --append --absolute-names --file="${tmp_tar_path}" -C "${tmp_path}" "netfilter.conf"
      fi

      echo_verbose "Buckup ${CMD} netfilter module config ..."
      local tmp_modprobe_netfilter_conig="${tmp_path}/mod_netfilter.conf"
      if [ "${NETFILTER_MOD_CONFIG_KEY_ARRAY}" ]; then
        for key in "${NETFILTER_MOD_CONFIG_KEY_ARRAY[@]}";
        do
          local fix_key=$(echo ${key} | tr '#' ' ')
          local val=$(yx_modprobe_config --read --key "${fix_key}")
          echo "${fix_key}=${val}"
          if [ -n "${val}" ]; then
            yx_modprobe_config --write --file "${tmp_modprobe_netfilter_conig}" --key "${key}" --val "${val}"
          fi
        done
      fi
      if [ -f "${tmp_modprobe_netfilter_conig}" ]; then
        ${TAR} --append --absolute-names --file="${tmp_tar_path}" -C "${tmp_path}" "mod_netfilter.conf"
      fi


      echo_verbose "Create the buckup file to destionation ..."
      local destination_dir=$(dirname "${path}")
      if [ ! -d "${destination_dir}" ]; then
        echo_err "DIR ${destination_dir} not exist, try create one"
        mkdir -p ${destination_dir} > /dev/null
        if [ ! -d  "${destination_dir}" ]; then
          echo_fatal "Failed to mkdir ${destination_dir}"
        fi
      fi

      local force_flag=''
      if ${force}; then
        force_flag='--force'
      fi
      echo_cmd "cp ${force_flag} ${tmp_tar_path} ${path}"

      echo_verbose "Verify package ..."
      if ! iptables_storage verify --path "${path}"; then
        echo_cmd "${RM} -f ${path}"
        echo_fatal "Verify failed. there is something wrong with new buckup file. delete it"
      fi

    
    elif strcontains "${option}" 'restore' --ignorecase; then

        echo_verbose "Verify package ..."
        # 验证备份文件
        if ! iptables_storage verify --path "${path}"; then
          echo_cmd "${RM} -f ${path}"
          echo_fatal "Verify failed. there is something wrong with new buckup file. delete it"
        fi

        # 解压到临时目录
        echo_verbose "Extra to path :${tmp_path} ..."
        if ! ${TAR} --extract --file="${path}" --directory="${tmp_path}"; then
          echo_fatal "Failed to extract buckup file"
        fi

        echo_verbose "Restore iptables'rule ..."
        # 恢复iptables dump 配置
        local save_dump_params=''
        local iptables_path="${tmp_path}/iptables"
        if [ -f "${iptables_path}" ]; then
          if ${IPTABLES_RESTORE} --test "${iptables_path}"; then
            echo_cmd "${IPTABLES_RESTORE} ${iptables_path}"
            if [[ $? == 0 ]]; then
              save_dump_params="${save_dump_params} --iptables-dump ${iptables_path}"
            else
              echo_fatal "Failed to restore iptables rule from data"
            fi
          fi
        fi
        # 恢复ip6tables dump 配置
        local ip6tables_path="${tmp_path}/ip6tables"
        if [ -f "${ip6tables_path}" ]; then
          if ${IP6TABLES_RESTORE} --test "${ip6tables_path}"; then
            echo_cmd "${IP6TABLES_RESTORE} ${ip6tables_path}"
            if [[ $? == 0 ]]; then
              save_dump_params="${save_dump_params} --ip6tables-dump ${ip6tables_path}"
            else
              echo_fatal "Failed to restore ip6tables rule from data"
            fi
          fi
        fi

        # Save iptables' dump file and create systemd service restore the dump at launch.
        echo_verbose "Create systemd service to restore the dump at launch ..."
        save_iptabls_dump ${save_dump_params}


        # 恢复net.xxx相关配置
        if [ "${NET_KEY_ARRAY}" ]; then

          echo_verbose "Clear all net item in sysctl.conf ..."
          # 删除所有sysctl.conf中net.xxx配置
          for key in "${NET_KEY_ARRAY[@]}"; do
            if yx_sysctl_config --exist --key "${key}"; then
              yx_sysctl_config --remove --key "${key}"
            fi
          done

          echo_verbose "Restore net item from storage ..."
          # 恢复buckup文件中net.xxx配置
          for key in $(yx_sysctl_config --all-keys --file "${tmp_path}/net.conf"); do
            local val=$(yx_sysctl_config --read --file "${tmp_path}/net.conf" --key "${key}")
            if [ -n "${val}" ]; then
              yx_sysctl_config --write --key "${key}" --val "${val}"
            fi
          done
        fi


        # 恢复 netfilter 相关配置
        if [ "${NETFILTER_KEY_ARRAY}" ]; then

          echo_verbose "Clear all netfilter items in sysctl.conf ..."
          # 删除所有sysctl.conf中netfilter.xxx配置
          for key in "${NETFILTER_KEY_ARRAY[@]}"; do
            if yx_sysctl_config --exist --key "${key}"; then
              yx_sysctl_config --remove --key "${key}"
            fi
          done

          echo_verbose "Restore netfilter item from storage ..."
          # 恢复buckup文件中netfilter.xxx配置
          for key in $(yx_sysctl_config --all-keys --file "${tmp_path}/netfilter.conf"); do
            local val=$(yx_sysctl_config --read --file "${tmp_path}/netfilter.conf" --key "${key}")
            if [ -n "${val}" ]; then
              yx_sysctl_config --write --key "${key}" --val "${val}"
            fi
          done
        fi
        
        # 恢复modprobe中的配置
        # 这里**暂时**只针对yxfirewall的配置文件
        if [ "${NETFILTER_MOD_CONFIG_KEY_ARRAY}" ]; then

          echo_verbose "Clear all items in modprobe/${CMD}.conf ..."
          # 删除所有sysctl.conf中netfilter.xxx配置
          for key in "${NETFILTER_MOD_CONFIG_KEY_ARRAY[@]}"; do
            local fix_key=$(echo ${key} | tr '#' ' ')
            if yx_modprobe_config --exist --key "${fix_key}"; then
              yx_modprobe_config --remove --key "${fix_key}"
            fi
          done

          echo_verbose "Restore modprobe item from storage ..."
          # 恢复buckup文件中modprobe.yxfirewall配置
          for key in $(yx_modprobe_config --all-keys --file "${tmp_path}/mod_netfilter.conf"); do
            local fix_key=$(echo ${key} | tr '#' ' ')
            local val=$(yx_modprobe_config --read --file "${tmp_path}/mod_netfilter.conf" --key "${key}")
            if [ -n "${val}" ]; then
              yx_modprobe_config --write --key "${fix_key}" --val "${val}"
            fi
          done
        fi

    elif strcontains "${option}" 'verify' --ignorecase; then

      local check_failed=false

      if [ ! -f "${path}" ]; then
        echo_fatal "File not exist :${path}"
      fi

      if ! ${check_failed}; then
        ${TAR} --extract --file="${path}" --directory="${tmp_path}"
        if [[ $? != 0 ]]; then
          check_failed=true
          echo_verbose "Package: extract failed"
        else
          echo_verbose "Package: OK"
        fi
      fi

      local iptables_path="${tmp_path}/iptables"
      if ! ${check_failed}; then
        if ! [ -f "${iptables_path}" ]; then
          check_failed=true
          echo_verbose "Package: iptables'rule not exist"
        else
          if ! "${IPTABLES_RESTORE}" --test "${iptables_path}"; then
            check_failed=true
            echo_verbose "Package: iptables'rule parse failed"
          else
            echo_verbose "iptables's rule: OK"
          fi
        fi
      fi

      local ip6tables_path="${tmp_path}/ip6tables"
      if ! ${check_failed}; then
        if [ ! -f "${ip6tables_path}" ]; then
          check_failed=true
          echo_verbose "Package: ip6tables'rule not exist"
        else
          if ! "${IP6TABLES_RESTORE}" --test "${ip6tables_path}"; then
            check_failed=true
            echo_verbose "Package: ip6tables'rule parse failed"
          else
            echo_verbose "ip6tables's rule: OK"
          fi
        fi
      fi

      local sysctl_path="${tmp_path}/sysctl.conf"
      if [ -f "${sysctl_path}" ]; then
        if ! [ -r "${sysctl_path}" ]; then
          check_failed=true
          echo_verbose "sysctl.conf: unreadable"
        else
          echo_verbose "sysctl.conf: OK"
        fi
      else
        echo_verbose "sysctl.conf: not exist"
      fi

      local netfilter_path="${tmp_path}/netfilter.conf"
      if [ -f "${netfilter_path}" ]; then
        if ! [ -r "${netfilter_path}" ]; then
          echo_verbose "netfilter.conf: unreadable"
          check_failed=true
        else
          echo_verbose "netfilter.conf: OK"
        fi
      else
        echo_verbose "netfilter.conf: not exist"
      fi

      local mod_netfilter_path="${tmp_path}/mod_netfilter.conf"
      if [ -f "${mod_netfilter_path}" ]; then
        if ! [ -r "${mod_netfilter_path}" ]; then
          check_failed=true
          echo_verbose "mod_netfilter.conf: unreadable"
        else
          echo_verbose "mod_netfilter.conf: OK"
        fi
      else
        echo_verbose "mod_netfilter.conf: not exist"
      fi

      if ${check_failed}; then
        return 1
      else
        return 0
      fi

    fi
  fi






}

####################################################################################################
# build-in handler
####################################################################################################


function handle_package_server()
{
  local chain=

  local interface=
  local not_interface=

  local ip=
  local not_ip=

  local port=

  local protocol=
  local protocol_flag=

  local logstr=

  local type=


  local option=$1
  if ! [[ "${option}" =~ ^-.*$ ]]; then
    shift
  else
    option=
  fi

  local additional=
  local cursor=
	while [ $# -gt 0 ]; do
		case $1 in

      --type )
        cursor=$1
				shift
        type=$1
			;;

      --chain )
        cursor=$1
				shift
        chain=$1
			;;

      --interface )
        cursor=$1
				shift
        interface=$1
			;;

      --not-interface )
        cursor=$1
				shift
        not_interface=$1
			;;

      --ip )
        cursor=$1
				shift
        ip=$1
			;;

      --no-ip )
        cursor=$1
				shift
        not_ip=$1
			;;
      
      --port )
        cursor=$1
				shift
        port=$1
			;;

      --proto )
        cursor=$1
				shift
				protocol=$1
			;;

      --log )
        cursor=$1
				shift
				logstr=$1
			;;

			--proto-flag )
        cursor=$1
				shift
        protocol_flag=$1
			;;

      ####################
      # For additional params
      ####################
			*)
        if [[ "${cursor}" == '--proto' ]] && [ "${protocol}" == 'tcp' ] && [ $1 == '--syn' ]; then
          protocol="${protocol} $1"
        elif [[ "${cursor}" == '--proto-flag' ]]; then
          protocol_flag="${protocol_flag} $1"
        else
          cursor='<additional>' # special cursor for additional params
          additional="${additional} $1"
        fi
				;;
		esac
		shift
	done



  # fix chain
  local chain_in=INPUT
  local chain_out=OUTPUT
  if [ -n "${chain}" ]; then
    if strcontains "${chain}" 'INPUT OUTPUT FORWARD PREROUTING POSTROUTING ACCEPT DROP REJECT RETURN' --ignorecase; then
      echo_fatal "Can not use chain with name '${chain}'. "
    else
      chain_in="${chain}"_in
      chain_out="${chain}"_out
    fi
  fi



  # params
  ####################

  local in_params=''
  local out_params=''

  # interface
  if [[ -n "${inter_in_list}" ]] && [[ "${inter_in_list}" != '*' ]]; then
    in_params="${in_params} --interface-in ${inter_in_list}"
    out_params="${out_params} --interface-out ${inter_in_list}"
  fi
  if [ -n "${not_interface}" ]; then
    in_params="${in_params} --not-interface-in ${not_interface}"
    out_params="${out_params} --not-interface-out ${not_interface}"
  fi

  # ip
  if [[ -n "${ip_in_list}" ]] && [[ "${ip_in_list}" != '*' ]]; then
      in_params="${in_params} --ip-from ${ip_in_list}"
      out_params="${out_params} --ip-to ${ip_in_list}"
  fi
  if [ -n "${not_ip}" ]; then
      in_params="${in_params} --not-ip-from ${not_ip}"
      out_params="${out_params} --not-ip-to ${not_ip}"
  fi

  # port
  local in_port_params=''
  local out_port_params=''
  if [ -n "${port}" ]; then
    in_port_params="--port-to ${port}"
    out_port_params="--port-from ${port}"
    in_params="${in_params} ${in_port_params}"
    out_params="${out_params} ${out_port_params}"
  fi

  # chain
  # local chain_params=''
  local chain_in_params=''
  local chain_out_params=''
  if [ -n "${chain_in}" ]; then
    chain_in_params="${chain_in_params} --chain ${chain_in}"
  fi
  if [ -n "${chain_out}" ]; then
    chain_out_params="${chain_out_params} --chain ${chain_out}"
  fi

  #log
  local log_params=''
  if [ -n "${logstr}" ]; then
    log_params="${log_params} --log ${logstr}"
  fi


  if strcontains "${option}" 'Drop Disable Block' --ignorecase; then
    echo_verbose 'Add bad-package rule...'
    # low-port on tdcp
    iptables_wrapper ${option} --proto tcp --port-from 0:19 ${chain_in_params}
    iptables_wrapper ${option} --proto tcp --port-to 0:19 ${chain_in_params}
    # low-port on udp
    iptables_wrapper ${option} --proto udp --port-to 0:21 ${chain_in_params}
    iptables_wrapper ${option} --proto udp --port-to 0:21 ${chain_in_params}

    # invalid package
    iptables_wrapper ${option} --proto ALL ${chain_in_params} ${in_params} --state INVALID ${log_params} ${additional}
    iptables_wrapper RETURN --proto ALL ${chain_in_params} ${in_params}
    if [ -n "${chain}" ]; then
      iptables_wrapper "${chain_in}" --chain INPUT ${in_params}
    fi
  else
    # Allow 不需要处理
    :
  fi


  return 0
}

function handle_synflood_server()
{
  local chain=

  local interface=
  local not_interface=

  local ip=
  local not_ip=

  local port=

  local protocol=
  local protocol_flag=

  local logstr=

  local type=


  local option=$1
  if ! [[ "${option}" =~ ^-.*$ ]]; then
    shift
  else
    option=
  fi

  local additional=
  local cursor=
	while [ $# -gt 0 ]; do
		case $1 in

      --type )
        cursor=$1
				shift
        type=$1
			;;

      --chain )
        cursor=$1
				shift
        chain=$1
			;;

      --interface )
        cursor=$1
				shift
        interface=$1
			;;

      --not-interface )
        cursor=$1
				shift
        not_interface=$1
			;;

      --ip )
        cursor=$1
				shift
        ip=$1
			;;

      --no-ip )
        cursor=$1
				shift
        not_ip=$1
			;;
      
      --port )
        cursor=$1
				shift
        port=$1
			;;

      --proto )
        cursor=$1
				shift
				protocol=$1
			;;

      --log )
        cursor=$1
				shift
				logstr=$1
			;;

			--proto-flag )
        cursor=$1
				shift
        protocol_flag=$1
			;;

      ####################
      # For additional params
      ####################
			*)
        if [[ "${cursor}" == '--proto' ]] && [ "${protocol}" == 'tcp' ] && [ $1 == '--syn' ]; then
          protocol="${protocol} $1"
        elif [[ "${cursor}" == '--proto-flag' ]]; then
          protocol_flag="${protocol_flag} $1"
        else
          cursor='<additional>' # special cursor for additional params
          additional="${additional} $1"
        fi
				;;
		esac
		shift
	done



  # fix chain
  local chain_in=INPUT
  local chain_out=OUTPUT
  if [ -n "${chain}" ]; then
    if strcontains "${chain}" 'INPUT OUTPUT FORWARD PREROUTING POSTROUTING ACCEPT DROP REJECT RETURN' --ignorecase; then
      echo_fatal "Can not use chain with name '${chain}'. "
    else
      chain_in="${chain}"_in
      chain_out="${chain}"_out
    fi
  fi



  # params
  ####################

  local in_params=''
  local out_params=''

  # interface
  if [[ -n "${inter_in_list}" ]] && [[ "${inter_in_list}" != '*' ]]; then
    in_params="${in_params} --interface-in ${inter_in_list}"
    out_params="${out_params} --interface-out ${inter_in_list}"
  fi
  if [ -n "${not_interface}" ]; then
    in_params="${in_params} --not-interface-in ${not_interface}"
    out_params="${out_params} --not-interface-out ${not_interface}"
  fi

  # ip
  if [[ -n "${ip_in_list}" ]] && [[ "${ip_in_list}" != '*' ]]; then
      in_params="${in_params} --ip-from ${ip_in_list}"
      out_params="${out_params} --ip-to ${ip_in_list}"
  fi
  if [ -n "${not_ip}" ]; then
      in_params="${in_params} --not-ip-from ${not_ip}"
      out_params="${out_params} --not-ip-to ${not_ip}"
  fi

  # port
  local in_port_params=''
  local out_port_params=''
  if [ -n "${port}" ]; then
    in_port_params="--port-to ${port}"
    out_port_params="--port-from ${port}"
    in_params="${in_params} ${in_port_params}"
    out_params="${out_params} ${out_port_params}"
  fi

  # chain
  # local chain_params=''
  local chain_in_params=''
  local chain_out_params=''
  if [ -n "${chain_in}" ]; then
    chain_in_params="${chain_in_params} --chain ${chain_in}"
  fi
  if [ -n "${chain_out}" ]; then
    chain_out_params="${chain_out_params} --chain ${chain_out}"
  fi

  #log
  local log_params=''
  if [ -n "${logstr}" ]; then
    log_params="${log_params} --log ${logstr}"
  fi

  if strcontains "${option}" 'Drop Disable Block' --ignorecase; then
    echo_verbose 'Add syn-flood rule...'
    iptables_wrapper RETURN --proto tcp --syn ${chain_in_params} ${in_params} --limit limit-upto:syn_flood:200/s:3:srcip:::300000
    iptables_wrapper LOG ${log_params} ${chain_in_params} ${in_params}
    iptables_wrapper DROP ${chain_in_params} ${in_params}

    if [ -n "${chain}" ]; then
      iptables_wrapper "${chain_in}" --proto tcp --syn --chain INPUT ${in_params} ${additional}
    fi

    # reduce retry times to 3 of syn and syn-ack packagte (default is 5)
    if ! yx_sysctl_config --write --refresh --key 'net.ipv4.tcp_synack_retries' --val 3; then
      echo_fatal "failed to change net.ipv4.tcp_synack_retries item to '3'"
    fi
    if ! yx_sysctl_config --write --refresh --key 'net.ipv4.tcp_syn_retries' --val 3; then
      echo_fatal "failed to change net.ipv4.tcp_syn_retries item to '3'"
    fi

    # enable syncookies (default is 0)
    if ! yx_sysctl_config --write --refresh --key 'net.ipv4.tcp_syncookies' --val 1; then
      echo_fatal "failed to change net.ipv4.tcp_syncookies item to '1'"
    fi

    # expand length of backlog queue (default is 1024)
    if ! yx_sysctl_config --write --refresh --key 'net.ipv4.tcp_max_syn_backlog' --val 2048; then
      echo_fatal "failed to change net.ipv4.tcp_syncookies item to '2048'"
    fi

    ###############################
    # 变更生效
    ###############################
    # sysctl
    yx_sysctl_config --refresh

  elif strcontains "${option}" 'ACCEPT ENABLE ALLOW' --ignorecase; then
    # Allow 不需要处理
    :
  fi


  # iptables_wrapper ${option} 
  # iptables_wrapper ${option} --proto ALL ${chain_in_params} ${in_params} --state INVALID ${log_params} ${additional}
  # iptables_wrapper RETURN --proto ALL ${chain_in_params}
  # if [ -n "${chain}" ]; then
  #   iptables_wrapper "${chain_in}" --proto tcp --syn --chain INPUT ${in_params} ${additional}
  # fi


  return 0
}

function handle_stealscan_server()
{
  local chain=

  local interface=
  local not_interface=

  local ip=
  local not_ip=

  local port=

  local protocol=
  local protocol_flag=

  local logstr=

  local type=


  local option=$1
  if ! [[ "${option}" =~ ^-.*$ ]]; then
    shift
  else
    option=
  fi

  local additional=
  local cursor=
	while [ $# -gt 0 ]; do
		case $1 in

      --type )
        cursor=$1
				shift
        type=$1
			;;

      --chain )
        cursor=$1
				shift
        chain=$1
			;;

      --interface )
        cursor=$1
				shift
        interface=$1
			;;

      --not-interface )
        cursor=$1
				shift
        not_interface=$1
			;;

      --ip )
        cursor=$1
				shift
        ip=$1
			;;

      --no-ip )
        cursor=$1
				shift
        not_ip=$1
			;;
      
      --port )
        cursor=$1
				shift
        port=$1
			;;

      --proto )
        cursor=$1
				shift
				protocol=$1
			;;

      --log )
        cursor=$1
				shift
				logstr=$1
			;;

			--proto-flag )
        cursor=$1
				shift
        protocol_flag=$1
			;;

      ####################
      # For additional params
      ####################
			*)
        if [[ "${cursor}" == '--proto' ]] && [ "${protocol}" == 'tcp' ] && [ $1 == '--syn' ]; then
          protocol="${protocol} $1"
        elif [[ "${cursor}" == '--proto-flag' ]]; then
          protocol_flag="${protocol_flag} $1"
        else
          cursor='<additional>' # special cursor for additional params
          additional="${additional} $1"
        fi
				;;
		esac
		shift
	done



  # fix chain 
  local chain_in=INPUT
  local chain_out=OUTPUT
  if [ -n "${chain}" ]; then
    if strcontains "${chain}" 'INPUT OUTPUT FORWARD PREROUTING POSTROUTING ACCEPT DROP REJECT RETURN' --ignorecase; then
      echo_fatal "Can not use chain with name '${chain}'. "
    else
      chain_in="${chain}"_in
      chain_out="${chain}"_out
    fi
  fi



  # params
  ####################

  local in_params=''
  local out_params=''

  # interface
  if [[ -n "${inter_in_list}" ]] && [[ "${inter_in_list}" != '*' ]]; then
    in_params="${in_params} --interface-in ${inter_in_list}"
    out_params="${out_params} --interface-out ${inter_in_list}"
  fi
  if [ -n "${not_interface}" ]; then
    in_params="${in_params} --not-interface-in ${not_interface}"
    out_params="${out_params} --not-interface-out ${not_interface}"
  fi

  # ip
  if [[ -n "${ip_in_list}" ]] && [[ "${ip_in_list}" != '*' ]]; then
      in_params="${in_params} --ip-from ${ip_in_list}"
      out_params="${out_params} --ip-to ${ip_in_list}"
  fi
  if [ -n "${not_ip}" ]; then
      in_params="${in_params} --not-ip-from ${not_ip}"
      out_params="${out_params} --not-ip-to ${not_ip}"
  fi

  # port
  local in_port_params=''
  local out_port_params=''
  if [ -n "${port}" ]; then
    in_port_params="--port-to ${port}"
    out_port_params="--port-from ${port}"
    in_params="${in_params} ${in_port_params}"
    out_params="${out_params} ${out_port_params}"
  fi

  # chain
  # local chain_params=''
  local chain_in_params=''
  local chain_out_params=''
  if [ -n "${chain_in}" ]; then
    chain_in_params="${chain_in_params} --chain ${chain_in}"
  fi
  if [ -n "${chain_out}" ]; then
    chain_out_params="${chain_out_params} --chain ${chain_out}"
  fi

  #log
  local log_params=''
  if [ -n "${logstr}" ]; then
    log_params="${log_params} --log ${logstr}"
  fi


  if strcontains "${option}" 'Block Drop Disable' --ignorecase; then
    ##########################################
    # 恶意 TCP 请求
    ##########################################
    #
    # 所有的 TCP 请求都必须经过以下规则过滤. 任何新请求都
    # 必须以一个 sync 包开始.
    # 如果不是这样的话,很可能表示这是一个扫描动作,这些有 
    # NEW 状态的包会被丢弃
    #
    # URG ACK PSH RST SYN FIN

    echo_verbose 'Add steal-scan rule...'

    # 010000(A) - legal
    # iptables_wrapper RETURN --proto tcp --proto-flag ALL ACK ${chain_in_params} ${in_params} --state ESTABLISHED ${log_params} ${additional}
    iptables_wrapper DROP --proto tcp --proto-flag ALL ACK ${chain_in_params} ${in_params} --state NEW,RELATED ${log_params} ${additional}
    # 011000(PA) - legal
    # iptables_wrapper RETURN --proto tcp --proto-flag ALL PSH,ACK ${chain_in_params} ${in_params} --state ESTABLISHED ${log_params} ${additional}
    #Occasionally iptables misclassifies as new
    # iptables_wrapper RETURN --proto tcp --proto-flag ALL PSH,ACK ${chain_in_params} ${in_params} --state NEW ${log_params} ${additional}
    iptables_wrapper DROP --proto tcp --proto-flag ALL PSH,ACK ${chain_in_params} ${in_params} --state RELATED ${log_params} ${additional}
    # 000000(NULL) - block(confirmed)
    iptables_wrapper DROP --proto tcp --proto-flag ALL NONE ${chain_in_params} ${in_params} ${log_params} ${additional}
    # 111111(XMAS) - block
    iptables_wrapper DROP --proto tcp --proto-flag ALL ALL ${chain_in_params} ${in_params} ${log_params} ${additional}
    # ????11(SF) - block(confirmed)
    iptables_wrapper DROP --proto tcp --proto-flag SYN,FIN SYN,FIN ${chain_in_params} ${in_params} ${log_params} ${additional}
    # ???11?(SR) - block(confirmed)
    iptables_wrapper DROP --proto tcp --proto-flag SYN,RST SYN,RST ${chain_in_params} ${in_params} ${log_params} ${additional}
    # ???1?1(RF) - block(confirmed)
    iptables_wrapper DROP --proto tcp --proto-flag RST,FIN RST,FIN ${chain_in_params} ${in_params} ${log_params} ${additional}
    # 1???1?(SU) - block(no payload on syn, cannot have urg data)
    iptables_wrapper DROP --proto tcp --proto-flag SYN,URG SYN,URG ${chain_in_params} ${in_params} ${log_params} ${additional}
    # 001010(SP) - block(no payload on syn)
    iptables_wrapper DROP --proto tcp --proto-flag ALL SYN,PSH ${chain_in_params} ${in_params} ${log_params} ${additional}
    # 011010(SAP) - block(no payload on syn/ack)
    iptables_wrapper DROP --proto tcp --proto-flag ALL SYN,ACK,PSH ${chain_in_params} ${in_params} ${log_params} ${additional}
    # ?0???1(F!A) - block(confirmed FIN but no ACK)
    iptables_wrapper DROP --proto tcp --proto-flag ACK,FIN FIN ${chain_in_params} ${in_params} ${log_params} ${additional}
    # ??0??1(P!A) - block(confirmed PSH but no ACK)
    iptables_wrapper DROP --proto tcp --proto-flag ACK,PSH PSH ${chain_in_params} ${in_params} ${log_params} ${additional}
    # 0????1(U!A) - block(confirmed URG but no ACK)
    iptables_wrapper DROP --proto tcp --proto-flag ACK,URG URG ${chain_in_params} ${in_params} ${log_params} ${additional}
    # 000100
    # RST only?  I get them from the razor servers, and gkrellm shipped a few back to noaa.gov after getting weather.
    # iptables_wrapper RETURN --proto tcp --proto-flag ALL RST ${chain_in_params} ${in_params} --state ESTABLISHED ${log_params} ${additional}
    iptables_wrapper DROP --proto tcp --proto-flag ALL RST ${chain_in_params} ${in_params} --state NEW,RELATED ${log_params} ${additional}
    # ?0??0?(!S!A) - block(neither SYN nor ACK)
    iptables_wrapper DROP --proto tcp --proto-flag SYN,ACK NONE ${chain_in_params} ${in_params} ${log_params} ${additional}
    # 000010(S) - legal
    #Normal sync's
    # iptables_wrapper RETURN --proto tcp --proto-flag ALL SYN ${chain_in_params} ${in_params} --state NEW ${log_params} ${additional} #Normal sync's
    #Opening syn of ftp data
    # iptables_wrapper RETURN --proto tcp --proto-flag ALL SYN ${chain_in_params} ${in_params} --state RELATED ${log_params} ${additional} #Opening syn of ftp data
    iptables_wrapper DROP --proto tcp --proto-flag ALL SYN ${chain_in_params} ${in_params} --state ESTABLISHED ${log_params} ${additional}
    # 010010(SA) - legal
    # iptables_wrapper RETURN --proto tcp --proto-flag ALL SYN,ACK ${chain_in_params} ${in_params} --state ESTABLISHED ${log_params} ${additional}
    #Common backscatter
    iptables_wrapper DROP --proto tcp --proto-flag ALL SYN,ACK ${chain_in_params} ${in_params} --state NEW,RELATED ${log_params} ${additional}
    # 010001(FA) - legal
    # iptables_wrapper RETURN --proto tcp --proto-flag ALL FIN,ACK ${chain_in_params} ${in_params} --state ESTABLISHED ${log_params} ${additional}
    iptables_wrapper DROP --proto tcp --proto-flag ALL FIN,ACK ${chain_in_params} ${in_params} --state NEW,RELATED ${log_params} ${additional}
    # 010100(RA) - legal
    # iptables_wrapper RETURN --proto tcp --proto-flag ALL RST,ACK ${chain_in_params} ${in_params} --state ESTABLISHED ${log_params} ${additional}
    #Common backscatter.  Occasionally iptables misclassifies as new
    # iptables_wrapper RETURN --proto tcp --proto-flag ALL RST,ACK ${chain_in_params} ${in_params} --state NEW ${log_params} ${additional}
    iptables_wrapper DROP --proto tcp --proto-flag ALL RST,ACK ${chain_in_params} ${in_params} --state RELATED ${log_params} ${additional}
    # 111000(APU) - legal(ctrl-c on telnet)
    # iptables_wrapper RETURN --proto tcp --proto-flag ALL ACK,PSH,RST ${chain_in_params} ${in_params} --state ESTABLISHED ${log_params} ${additional}
    iptables_wrapper DROP --proto tcp --proto-flag ALL ACK,PSH,RST ${chain_in_params} ${in_params} --state NEW,RELATED ${log_params} ${additional}
    # 011001(FPA) - RETURN(FIN implies a push, but we're seeing this on legit traffic)
    # iptables_wrapper RETURN --proto tcp --proto-flag ALL FIN,PSH,ACK ${chain_in_params} ${in_params} --state ESTABLISHED ${log_params} ${additional}
    iptables_wrapper DROP --proto tcp --proto-flag ALL FIN,PSH,ACK ${chain_in_params} ${in_params} --state NEW,RELATED ${log_params} ${additional}


    ####################################################################################################
    # 应该可以 block的
    ####################################################################################################
    # 101001(FUP) - block?
    iptables_wrapper DROP --proto tcp --proto-flag ALL FIN,URG,PSH ${chain_in_params} ${in_params} ${log_params} ${additional}
    # 110111(SRAFU) - block?
    iptables_wrapper DROP --proto tcp --proto-flag ALL SYN,RST,ACK,FIN,URG ${chain_in_params} ${in_params} ${log_params} ${additional}

    ####################################################################################################
    # 不确定, 保守使用
    ####################################################################################################
    # 011100(RAP) - block?
    iptables_wrapper DROP --proto tcp --proto-flag ALL RST,ACK,PSH ${chain_in_params} ${in_params} ${log_params} ${additional}
    # 110100(RAU) - block?
    iptables_wrapper DROP --proto tcp --proto-flag ALL RST,ACK,URG ${chain_in_params} ${in_params} ${log_params} ${additional}
    # 111100(RAPU) - block?
    iptables_wrapper DROP --proto tcp --proto-flag ALL RST,ACK,PSH,URG ${chain_in_params} ${in_params} ${log_params} ${additional}
    # 111001(FPAU) - block?(FIN implies a push)
    iptables_wrapper DROP --proto tcp --proto-flag ALL FIN,PSH,ACK,URG ${chain_in_params} ${in_params} ${log_params} ${additional}
    # 110000(AU) - block?(APU more likely)
    iptables_wrapper DROP --proto tcp --proto-flag ALL ACK,URG ${chain_in_params} ${in_params} ${log_params} ${additional}
    # 110001(AUF) - block?
    iptables_wrapper DROP --proto tcp --proto-flag ALL ACK,URG,FIN ${chain_in_params} ${in_params} ${log_params} ${additional}

    ####################################################################################################
    # Return
    ####################################################################################################
    iptables_wrapper RETURN ${chain_in_params} ${in_params}



    # iptables_wrapper ${option} --proto ALL ${chain_in_params} ${in_params} --state INVALID ${log_params} ${additional}
    # iptables_wrapper RETURN --proto ALL ${chain_in_params}
    if [ -n "${chain}" ]; then
      iptables_wrapper "${chain_in}" --proto tcp --chain INPUT ${in_params}
    fi
  fi



  return 0
}

function handle_broadcast_server()
{
  local chain=

  local interface=
  local not_interface=

  local ip=
  local not_ip=

  local port=

  local protocol=
  local protocol_flag=

  local logstr=

  local type=


  local option=$1
  if ! [[ "${option}" =~ ^-.*$ ]]; then
    shift
  else
    option=
  fi

  local additional=
  local cursor=
	while [ $# -gt 0 ]; do
		case $1 in

      --type )
        cursor=$1
				shift
        type=$1
			;;

      --chain )
        cursor=$1
				shift
        chain=$1
			;;

      --interface )
        cursor=$1
				shift
        interface=$1
			;;

      --not-interface )
        cursor=$1
				shift
        not_interface=$1
			;;

      --ip )
        cursor=$1
				shift
        ip=$1
			;;

      --no-ip )
        cursor=$1
				shift
        not_ip=$1
			;;
      
      --port )
        cursor=$1
				shift
        port=$1
			;;

      --proto )
        cursor=$1
				shift
				protocol=$1
			;;

      --log )
        cursor=$1
				shift
				logstr=$1
			;;

			--proto-flag )
        cursor=$1
				shift
        protocol_flag=$1
			;;

      ####################
      # For additional params
      ####################
			*)
        if [[ "${cursor}" == '--proto' ]] && [ "${protocol}" == 'tcp' ] && [ $1 == '--syn' ]; then
          protocol="${protocol} $1"
        elif [[ "${cursor}" == '--proto-flag' ]]; then
          protocol_flag="${protocol_flag} $1"
        else
          cursor='<additional>' # special cursor for additional params
          additional="${additional} $1"
        fi
				;;
		esac
		shift
	done



  # fix chain
  local chain_in=INPUT
  local chain_out=OUTPUT
  if [ -n "${chain}" ]; then
    if strcontains "${chain}" 'INPUT OUTPUT FORWARD PREROUTING POSTROUTING ACCEPT DROP REJECT RETURN' --ignorecase; then
      echo_fatal "Can not use chain with name '${chain}'. "
    else
      chain_in="${chain}"_in
      chain_out="${chain}"_out
    fi
  fi



  # params
  ####################

  local in_params=''
  local out_params=''

  # interface
  if [[ -n "${inter_in_list}" ]] && [[ "${inter_in_list}" != '*' ]]; then
    in_params="${in_params} --interface-in ${inter_in_list}"
    out_params="${out_params} --interface-out ${inter_in_list}"
  fi
  if [ -n "${not_interface}" ]; then
    in_params="${in_params} --not-interface-in ${not_interface}"
    out_params="${out_params} --not-interface-out ${not_interface}"
  fi

  # ip
  if [[ -n "${ip_in_list}" ]] && [[ "${ip_in_list}" != '*' ]]; then
      in_params="${in_params} --ip-from ${ip_in_list}"
      out_params="${out_params} --ip-to ${ip_in_list}"
  fi
  if [ -n "${not_ip}" ]; then
      in_params="${in_params} --not-ip-from ${not_ip}"
      out_params="${out_params} --not-ip-to ${not_ip}"
  fi

  # port
  local in_port_params=''
  local out_port_params=''
  if [ -n "${port}" ]; then
    in_port_params="--port-to ${port}"
    out_port_params="--port-from ${port}"
    in_params="${in_params} ${in_port_params}"
    out_params="${out_params} ${out_port_params}"
  fi

  # chain
  # local chain_params=''
  local chain_in_params=''
  local chain_out_params=''
  if [ -n "${chain_in}" ]; then
    chain_in_params="${chain_in_params} --chain ${chain_in}"
  fi
  if [ -n "${chain_out}" ]; then
    chain_out_params="${chain_out_params} --chain ${chain_out}"
  fi

  #log
  local log_params=''
  if [ -n "${logstr}" ]; then
    log_params="${log_params} --log ${logstr}"
  fi


  if strcontains "${option}" 'Block Drop Disable' --ignorecase; then
    ###########################################################
    # 发往所有主机（广播地址、组播地址）的数据包
    ###########################################################
    echo_verbose 'Add broadcast package rule...'
    iptables_wrapper ${option} --ip-to 192.168.1.255 ${chain_in_params} ${in_params} ${log_params} ${additional}
    iptables_wrapper ${option} --ip-to 255.255.255.255 ${chain_in_params} ${in_params} ${log_params} ${additional}
    iptables_wrapper ${option} --ip-to 224.0.0.1 ${chain_in_params} ${in_params} ${log_params} ${additional}

    if [ -n "${chain}" ]; then
      iptables_wrapper RETURN ${chain_in_params} ${in_params}
      iptables_wrapper "${chain_in}" --proto tcp --chain INPUT ${in_params}
    fi
  fi


  return 0
}

function handle_icmp_server_and_client()
{
  local chain=

  local interface=
  local not_interface=

  local ip=
  local not_ip=

  local port=

  local protocol=
  local protocol_flag=

  local logstr=

  local type=


  local option=$1
  if ! [[ "${option}" =~ ^-.*$ ]]; then
    shift
  else
    option=
  fi

  local additional=
  local cursor=
	while [ $# -gt 0 ]; do
		case $1 in

      --type )
        cursor=$1
				shift
        type=$1
			;;

      --chain )
        cursor=$1
				shift
        chain=$1
			;;

      --interface )
        cursor=$1
				shift
        interface=$1
			;;

      --not-interface )
        cursor=$1
				shift
        not_interface=$1
			;;

      --ip )
        cursor=$1
				shift
        ip=$1
			;;

      --no-ip )
        cursor=$1
				shift
        not_ip=$1
			;;
      
      --port )
        cursor=$1
				shift
        port=$1
			;;

      --proto )
        cursor=$1
				shift
				protocol=$1
			;;

      --log )
        cursor=$1
				shift
				logstr=$1
			;;

			--proto-flag )
        cursor=$1
				shift
        protocol_flag=$1
			;;

      ####################
      # For additional params
      ####################
			*)
        if [[ "${cursor}" == '--proto' ]] && [ "${protocol}" == 'tcp' ] && [ $1 == '--syn' ]; then
          protocol="${protocol} $1"
        elif [[ "${cursor}" == '--proto-flag' ]]; then
          protocol_flag="${protocol_flag} $1"
        else
          cursor='<additional>' # special cursor for additional params
          additional="${additional} $1"
        fi
				;;
		esac
		shift
	done



  # fix chain
  local chain_in=INPUT
  local chain_out=OUTPUT
  if [ -n "${chain}" ]; then
    if strcontains "${chain}" 'INPUT OUTPUT FORWARD PREROUTING POSTROUTING ACCEPT DROP REJECT RETURN' --ignorecase; then
      echo_fatal "Can not use chain with name '${chain}'. "
    else
      chain_in="${chain}"_in
      chain_out="${chain}"_out
    fi
  fi



  # params
  ####################

  local in_params=''
  local out_params=''

  # interface
  if [[ -n "${inter_in_list}" ]] && [[ "${inter_in_list}" != '*' ]]; then
    in_params="${in_params} --interface-in ${inter_in_list}"
    out_params="${out_params} --interface-out ${inter_in_list}"
  fi
  if [ -n "${not_interface}" ]; then
    in_params="${in_params} --not-interface-in ${not_interface}"
    out_params="${out_params} --not-interface-out ${not_interface}"
  fi

  # ip
  if [[ -n "${ip_in_list}" ]] && [[ "${ip_in_list}" != '*' ]]; then
      in_params="${in_params} --ip-from ${ip_in_list}"
      out_params="${out_params} --ip-to ${ip_in_list}"
  fi
  if [ -n "${not_ip}" ]; then
      in_params="${in_params} --not-ip-from ${not_ip}"
      out_params="${out_params} --not-ip-to ${not_ip}"
  fi

  # port
  local in_port_params=''
  local out_port_params=''
  if [ -n "${port}" ]; then
    in_port_params="--port-to ${port}"
    out_port_params="--port-from ${port}"
    in_params="${in_params} ${in_port_params}"
    out_params="${out_params} ${out_port_params}"
  fi

  # chain
  # local chain_params=''
  local chain_in_params=''
  local chain_out_params=''
  if [ -n "${chain_in}" ]; then
    chain_in_params="${chain_in_params} --chain ${chain_in}"
  fi
  if [ -n "${chain_out}" ]; then
    chain_out_params="${chain_out_params} --chain ${chain_out}"
  fi

  #log
  local log_params=''
  if [ -n "${logstr}" ]; then
    log_params="${log_params} --log ${logstr}"
  fi


  echo_verbose 'Add icmp rule...'
  if [[ "${type}" == "server" ]]; then
    ##########################################
    # ICMP 包规则
    ##########################################

    # 将ICMP 默认超时时间，从30秒改为10妙
    if ! yx_sysctl_config --write --key "net.netfilter.nf_conntrack_icmp_timeout" --val '10'; then
      echo_fatal "failed to change 'net.netfilter.nf_conntrack_icmp_timeout' to 10"
    fi
    if ! yx_sysctl_config --write --key "net.netfilter.nf_conntrack_icmpv6_timeout" --val '10'; then
      echo_fatal "failed to change 'net.netfilter.nf_conntrack_icmpv6_timeout' to 10"
    fi


    #
    # 1. ICMP 包必须封装在一个2层的帧中,因此它们不会有碎片, 带有碎片的 ICMP 包通常被标记为恶意攻击
    # 2. 10 次 ping 超过每秒 1 次后丢弃

    if strcontains "${option}" 'Allow Accept Enable' --ignorecase; then
      # 丢弃 fragment
      iptables_wrapper DROP --proto icmp --fragment ${chain_in_params} ${in_params} ${log_params} ${additional}


      # ping limit 限制 incoming
      iptables_wrapper ACCEPT --proto icmp --proto-flag echo-request ${chain_in_params} --limit limit-upto:ping_attack:1/s:10:srcip:::300000 ${in_params} --state NEW,ESTABLISHED ${log_params} ${additional}
      # 永久禁用icmp时间戳 incoming
      iptables_wrapper DROP --proto icmp --proto-flag timestamp-request ${chain_in_params} ${in_params} ${additional}

      # ping limit 限制 outgoing
      iptables_wrapper ACCEPT --proto icmp --proto-flag echo-reply ${chain_out_params} ${out_params} --state ESTABLISHED
      # 永久禁用icmp时间戳 outgoing
      iptables_wrapper DROP --proto icmp --proto-flag timestamp-reply ${chain_out_params} ${out_params} ${additional}

    elif strcontains "${option}" 'Block Drop Disable' --ignorecase; then

      # 丢弃 fragment
      iptables_wrapper DROP --proto icmp --fragment ${chain_in_params} ${in_params} ${log_params} ${additional}


      # ping limit 限制 incoming
      iptables_wrapper DROP --proto icmp --proto-flag echo-request ${chain_in_params} ${in_params} --state NEW,ESTABLISHED ${log_params} ${additional}
      # 永久禁用icmp时间戳 incoming
      iptables_wrapper DROP --proto icmp --proto-flag timestamp-request ${chain_in_params} ${in_params} ${additional}

      # ping limit 限制 outgoing
      iptables_wrapper DROP --proto icmp --proto-flag echo-reply ${chain_out_params} ${out_params} --state ESTABLISHED
      # 永久禁用icmp时间戳 outgoing
      iptables_wrapper DROP --proto icmp --proto-flag timestamp-reply ${chain_out_params} ${out_params} ${additional}

    else
      return 1
    fi

  elif [[ "${type}" == "client" ]]; then

    # ping limit 限制 outgoing
    iptables_wrapper ${option} --proto icmp --proto-flag echo-request ${chain_out_params} ${out_params} --state NEW,ESTABLISHED ${log_params} ${additional}
    # icmp 时间戳 限制 outgoing
    iptables_wrapper ${option} --proto icmp --proto-flag timestamp-request ${chain_out_params} ${out_params} --state NEW,ESTABLISHED ${log_params} ${additional}

    # ping limit 限制 incoming
    iptables_wrapper ${option} --proto icmp --proto-flag echo-reply ${chain_in_params} ${in_params} --state ESTABLISHED
    # icmp 时间戳 限制 incoming
    iptables_wrapper ${option} --proto icmp --proto-flag timestamp-reply ${chain_in_params} ${in_params} --state ESTABLISHED

  fi

  if [ -n "${chain}" ]; then
    iptables_wrapper "${chain_in}" --proto icmp --chain INPUT ${in_params}
    iptables_wrapper "${chain_out}" --proto icmp --chain OUTPUT ${out_params}
  fi


  return 0
}

# SSH
####################################################################################################

function handle_ssh_server()
{

  local chain=

  local interface=
  local not_interface=

  local ip=
  local not_ip=

  local port=

  local protocol=
  local protocol_flag=

  local logstr=

  local type=


  local option=$1
  if ! [[ "${option}" =~ ^-.*$ ]]; then
    shift
  else
    option=
  fi

  local additional=
  local cursor=
	while [ $# -gt 0 ]; do
		case $1 in

      --type )
        cursor=$1
				shift
        type=$1
			;;

      --chain )
        cursor=$1
				shift
        chain=$1
			;;

      --interface )
        cursor=$1
				shift
        interface=$1
			;;

      --not-interface )
        cursor=$1
				shift
        not_interface=$1
			;;

      --ip )
        cursor=$1
				shift
        ip=$1
			;;

      --no-ip )
        cursor=$1
				shift
        not_ip=$1
			;;
      
      --port )
        cursor=$1
				shift
        port=$1
			;;

      --proto )
        cursor=$1
				shift
				protocol=$1
			;;

      --log )
        cursor=$1
				shift
				logstr=$1
			;;

			--proto-flag )
        cursor=$1
				shift
        protocol_flag=$1
			;;

      ####################
      # For additional params
      ####################
			*)
        if [[ "${cursor}" == '--proto' ]] && [ "${protocol}" == 'tcp' ] && [ $1 == '--syn' ]; then
          protocol="${protocol} $1"
        elif [[ "${cursor}" == '--proto-flag' ]]; then
          protocol_flag="${protocol_flag} $1"
        else
          cursor='<additional>' # special cursor for additional params
          additional="${additional} $1"
        fi
				;;
		esac
		shift
	done



  # fix params
  ####################
  # # fix port
  if [ -z "${port}" ]; then
    #if no port num from config file. try use default port number
    port="${DEFAULT_PORT[SSH]}"
    if [ -z "${port}" ]; then
      echo_fatal "Failed to find a valid port number on SSH server"
    fi
  fi



  # fix chain
  local chain_in=INPUT
  local chain_out=OUTPUT
  if [ -n "${chain}" ]; then
    if strcontains "${chain}" 'INPUT OUTPUT FORWARD PREROUTING POSTROUTING ACCEPT DROP REJECT RETURN' --ignorecase; then
      echo_fatal "Can not use chain with name '${chain}'. "
    else
      chain_in="${chain}"_in
      chain_out="${chain}"_out
    fi
  fi



  # params
  ####################

  local in_params=''
  local out_params=''

  # interface
  if [[ -n "${inter_in_list}" ]] && [[ "${inter_in_list}" != '*' ]]; then
    in_params="${in_params} --interface-in ${inter_in_list}"
    out_params="${out_params} --interface-out ${inter_in_list}"
  fi
  if [ -n "${not_interface}" ]; then
    in_params="${in_params} --not-interface-in ${not_interface}"
    out_params="${out_params} --not-interface-out ${not_interface}"
  fi

  # ip
  if [[ -n "${ip_in_list}" ]] && [[ "${ip_in_list}" != '*' ]]; then
      in_params="${in_params} --ip-from ${ip_in_list}"
      out_params="${out_params} --ip-to ${ip_in_list}"
  fi
  if [ -n "${not_ip}" ]; then
      in_params="${in_params} --not-ip-from ${not_ip}"
      out_params="${out_params} --not-ip-to ${not_ip}"
  fi

  # port
  local in_port_params=''
  local out_port_params=''
  if [ -n "${port}" ]; then
    in_port_params="--port-to ${port}"
    out_port_params="--port-from ${port}"
    in_params="${in_params} ${in_port_params}"
    out_params="${out_params} ${out_port_params}"
  fi

  # chain
  # local chain_params=''
  local chain_in_params=''
  local chain_out_params=''
  if [ -n "${chain_in}" ]; then
    chain_in_params="${chain_in_params} --chain ${chain_in}"
  fi
  if [ -n "${chain_out}" ]; then
    chain_out_params="${chain_out_params} --chain ${chain_out}"
  fi

  #log
  local log_params=''
  if [ -n "${logstr}" ]; then
    log_params="${log_params} --log ${logstr}"
  fi


  echo_verbose 'Add ssh rule...'
  if strcontains "${option}" 'ACCEPT ENABLE ALLOW' --ignorecase; then

    ###########################################################
    # 攻击防护：SSH 暴力破解
    # SSH为使用密码认证的服务器准备密码暴力攻击。
    # 每分钟只允许 5 次连接尝试。
    # REJECT 而不是 DROP 以防止 SSH 客户端重复重新连接。
    # 如果 SSH 服务器开启了密码认证，请取消注释掉以下内容。
    ###########################################################
    # REJECT-WITH tcp-reset
    iptables_wrapper REJECT-WITH icmp-port-unreachable --proto tcp ${chain_in_params} ${in_params} --limit recent-check:ssh_attack:60:5 --state NEW ${log_params} ${additional}
    iptables_wrapper --proto tcp ${chain_in_params} ${in_params} --limit recent-set:ssh_attack --state NEW 

    iptables_wrapper ACCEPT --proto tcp ${chain_in_params} ${in_params} --state NEW,ESTABLISHED ${additional}
    iptables_wrapper ACCEPT ${chain_out_params} --proto tcp ${out_params} --state ESTABLISHED ${additional}

  elif strcontains "${option}" 'DROP DISABLE BLOCK' --ignorecase; then

    ###########################################################
    # Same as ${CMD} service DROP --proto tcp --port 22
    ###########################################################
    iptables_wrapper "${option}" --proto tcp ${chain_in_params} ${in_params} --state NEW,ESTABLISHED ${additional}
    iptables_wrapper "${option}" --proto tcp ${chain_out_params} ${out_params} --state ESTABLISHED ${additional}

  fi

  if [ -n "${chain}" ]; then
    iptables_wrapper "${chain_in}" --proto tcp --chain INPUT ${in_params}
    iptables_wrapper "${chain_out}" --proto tcp --chain OUTPUT ${out_params}
  fi

  return 0

}

function handle_web_server()
{

  local chain=

  local interface=
  local not_interface=

  local ip=
  local not_ip=

  local port=

  local protocol=
  local protocol_flag=

  local logstr=

  local type=


  local option=$1
  if ! [[ "${option}" =~ ^-.*$ ]]; then
    shift
  else
    option=
  fi

  local additional=
  local cursor=
	while [ $# -gt 0 ]; do
		case $1 in

      --type )
        cursor=$1
				shift
        type=$1
			;;

      --chain )
        cursor=$1
				shift
        chain=$1
			;;

      --interface )
        cursor=$1
				shift
        interface=$1
			;;

      --not-interface )
        cursor=$1
				shift
        not_interface=$1
			;;

      --ip )
        cursor=$1
				shift
        ip=$1
			;;

      --no-ip )
        cursor=$1
				shift
        not_ip=$1
			;;
      
      --port )
        cursor=$1
				shift
        port=$1
			;;

      --proto )
        cursor=$1
				shift
				protocol=$1
			;;

      --log )
        cursor=$1
				shift
				logstr=$1
			;;

			--proto-flag )
        cursor=$1
				shift
        protocol_flag=$1
			;;

      ####################
      # For additional params
      ####################
			*)
        if [[ "${cursor}" == '--proto' ]] && [ "${protocol}" == 'tcp' ] && [ $1 == '--syn' ]; then
          protocol="${protocol} $1"
        elif [[ "${cursor}" == '--proto-flag' ]]; then
          protocol_flag="${protocol_flag} $1"
        else
          cursor='<additional>' # special cursor for additional params
          additional="${additional} $1"
        fi
				;;
		esac
		shift
	done



  # fix chain
  local chain_in=INPUT
  local chain_out=OUTPUT
  if [ -n "${chain}" ]; then
    if strcontains "${chain}" 'INPUT OUTPUT FORWARD PREROUTING POSTROUTING ACCEPT DROP REJECT RETURN' --ignorecase; then
      echo_fatal "Can not use chain with name '${chain}'. "
    else
      chain_in="${chain}"_in
      chain_out="${chain}"_out
    fi
  fi



  # params
  ####################

  local in_params=''
  local out_params=''

  # interface
  if [[ -n "${inter_in_list}" ]] && [[ "${inter_in_list}" != '*' ]]; then
    in_params="${in_params} --interface-in ${inter_in_list}"
    out_params="${out_params} --interface-out ${inter_in_list}"
  fi
  if [ -n "${not_interface}" ]; then
    in_params="${in_params} --not-interface-in ${not_interface}"
    out_params="${out_params} --not-interface-out ${not_interface}"
  fi

  # ip
  if [[ -n "${ip_in_list}" ]] && [[ "${ip_in_list}" != '*' ]]; then
      in_params="${in_params} --ip-from ${ip_in_list}"
      out_params="${out_params} --ip-to ${ip_in_list}"
  fi
  if [ -n "${not_ip}" ]; then
      in_params="${in_params} --not-ip-from ${not_ip}"
      out_params="${out_params} --not-ip-to ${not_ip}"
  fi

  # port
  local in_port_params=''
  local out_port_params=''
  if [ -n "${port}" ]; then
    in_port_params="--port-to ${port}"
    out_port_params="--port-from ${port}"
    in_params="${in_params} ${in_port_params}"
    out_params="${out_params} ${out_port_params}"
  fi

  # chain
  # local chain_params=''
  local chain_in_params=''
  local chain_out_params=''
  if [ -n "${chain_in}" ]; then
    chain_in_params="${chain_in_params} --chain ${chain_in}"
  fi
  if [ -n "${chain_out}" ]; then
    chain_out_params="${chain_out_params} --chain ${chain_out}"
  fi

  #log
  local log_params=''
  if [ -n "${logstr}" ]; then
    log_params="${log_params} --log ${logstr}"
  fi


  echo_verbose "Add web rule on port ${port}..."
  if strcontains "${option}" 'ACCEPT ENABLE ALLOW' --ignorecase; then

    ###########################################################
    # 攻击防护：HTTP/HTTPS 
    # 每秒只允许1次连接尝试。
    # 100次超过上限将受到限制
    # 生存期300秒
    ##################################################

    iptables_wrapper ACCEPT --proto tcp ${chain_in_params} --limit limit-upto:http_dos:1/s:100:srcip:::300000 ${in_params} --state NEW,ESTABLISHED ${additional}
    iptables_wrapper DROP --proto tcp ${chain_in_params} ${out_params} ${log_params} ${additional}

    iptables_wrapper ACCEPT --proto tcp ${chain_out_params} ${in_params} --state ESTABLISHED ${additional}

  elif strcontains "${option}" 'DROP DISABLE BLOCK' --ignorecase; then
     iptables_wrapper DROP --proto tcp ${chain_in_params} ${in_params} --state NEW,ESTABLISHED ${additional}
     iptables_wrapper DROP --proto tcp ${chain_out_params} ${out_params} --state ESTABLISHED ${additional}
      
      # iptables_wrapper DROP --proto tcp --chain INPUT ${in_params} --state NEW ${additional}
  fi

  if [ -n "${chain}" ]; then
    iptables_wrapper "${chain_in}" --proto tcp --chain INPUT ${in_params}
    iptables_wrapper "${chain_out}" --proto tcp --chain OUTPUT ${out_params}
  fi




  return 0

}

function handle_ftp_server_and_client()
{

  local chain=

  local interface=
  local not_interface=

  local ip=
  local not_ip=

  local port=

  local protocol=
  local protocol_flag=

  local logstr=

  local type=


  local option=$1
  if ! [[ "${option}" =~ ^-.*$ ]]; then
    shift
  else
    option=
  fi

  local additional=
  local cursor=
	while [ $# -gt 0 ]; do
		case $1 in

      --type )
        cursor=$1
				shift
        type=$1
			;;

      --chain )
        cursor=$1
				shift
        chain=$1
			;;

      --interface )
        cursor=$1
				shift
        interface=$1
			;;

      --not-interface )
        cursor=$1
				shift
        not_interface=$1
			;;

      --ip )
        cursor=$1
				shift
        ip=$1
			;;

      --no-ip )
        cursor=$1
				shift
        not_ip=$1
			;;
      
      --port )
        cursor=$1
				shift
        port=$1
			;;

      --proto )
        cursor=$1
				shift
				protocol=$1
			;;

      --log )
        cursor=$1
				shift
				logstr=$1
			;;

			--proto-flag )
        cursor=$1
				shift
        protocol_flag=$1
			;;

      ####################
      # For additional params
      ####################
			*)
        if [[ "${cursor}" == '--proto' ]] && [ "${protocol}" == 'tcp' ] && [ $1 == '--syn' ]; then
          protocol="${protocol} $1"
        elif [[ "${cursor}" == '--proto-flag' ]]; then
          protocol_flag="${protocol_flag} $1"
        else
          cursor='<additional>' # special cursor for additional params
          additional="${additional} $1"
        fi
				;;
		esac
		shift
	done



  # fix chain
  local chain_in=INPUT
  local chain_out=OUTPUT
  if [ -n "${chain}" ]; then
    if strcontains "${chain}" 'INPUT OUTPUT FORWARD PREROUTING POSTROUTING ACCEPT DROP REJECT RETURN' --ignorecase; then
      echo_fatal "Can not use chain with name '${chain}'. "
    else
      chain_in="${chain}"_in
      chain_out="${chain}"_out
    fi
  fi



  # params
  ####################

  local in_params=''
  local out_params=''

  # interface
  if [[ -n "${inter_in_list}" ]] && [[ "${inter_in_list}" != '*' ]]; then
    in_params="${in_params} --interface-in ${inter_in_list}"
    out_params="${out_params} --interface-out ${inter_in_list}"
  fi
  if [ -n "${not_interface}" ]; then
    in_params="${in_params} --not-interface-in ${not_interface}"
    out_params="${out_params} --not-interface-out ${not_interface}"
  fi

  # ip
  if [[ -n "${ip_in_list}" ]] && [[ "${ip_in_list}" != '*' ]]; then
      in_params="${in_params} --ip-from ${ip_in_list}"
      out_params="${out_params} --ip-to ${ip_in_list}"
  fi
  if [ -n "${not_ip}" ]; then
      in_params="${in_params} --not-ip-from ${not_ip}"
      out_params="${out_params} --not-ip-to ${not_ip}"
  fi

  # port
  # 这里port不计入 in_params 和 out_params
  local in_port_params=''
  local out_port_params=''
  if [ -n "${port}" ]; then
    in_port_params="--port-to ${port}"
    out_port_params="--port-from ${port}"
    # in_params="${in_params} ${in_port_params}"
    # out_params="${out_params} ${out_port_params}"
  fi

  # chain
  # local chain_params=''
  local chain_in_params=''
  local chain_out_params=''
  if [ -n "${chain_in}" ]; then
    chain_in_params="${chain_in_params} --chain ${chain_in}"
  fi
  if [ -n "${chain_out}" ]; then
    chain_out_params="${chain_out_params} --chain ${chain_out}"
  fi

  #log
  local log_params=''
  if [ -n "${logstr}" ]; then
    log_params="${log_params} --log ${logstr}"
  fi


  echo_verbose 'Add FTP rule...'
  if [[ ${type} == "server" ]]; then
      if strcontains "${option}" 'ACCEPT ENABLE ALLOW' --ignorecase; then

        # Allow FTP connections on port 21 incoming
        iptables_wrapper ACCEPT --proto tcp --port-to 21 ${chain_in_params} ${in_params} --state NEW,ESTABLISHED ${additional}
        # Allow FTP port 20 for active connections incoming
        iptables_wrapper ACCEPT --proto tcp --port-to 20 ${chain_in_params} ${in_params} --state ESTABLISHED ${additional}
        # Finally allow FTP passive inbound traffic incoming
        iptables_wrapper ACCEPT --proto tcp ${in_port_params} ${chain_in_params} ${in_params} --state ESTABLISHED,RELATED ${additional}

        # Allow FTP connections on port 21 outgoing
        iptables_wrapper ACCEPT --proto tcp --port-from 21 ${chain_out_params} ${out_params} --state ESTABLISHED ${additional}
        # Allow FTP port 20 for active connections outgoing
        iptables_wrapper ACCEPT --proto tcp --port-from 20 ${chain_out_params} ${out_params} --state ESTABLISHED,RELATED ${additional}
        # Finally allow FTP passive inbound traffic outgoing
        iptables_wrapper ACCEPT --proto tcp ${out_port_params} ${chain_out_params} ${out_params} --state ESTABLISHED ${additional}

      elif strcontains "${option}" 'DROP DISABLE BLOCK' --ignorecase; then

        # DROP FTP connections on port 21 incoming
        iptables_wrapper DROP --proto tcp --port-to 21 ${chain_in_params} ${in_params} --state NEW ${additional}
        # Allow FTP port 20 for active connections outgoing
        iptables_wrapper DROP --proto tcp --port-from 20 ${chain_out_params} ${out_params} --state RELATED ${additional}
        # Finally allow FTP passive inbound traffic incoming
        iptables_wrapper DROP --proto tcp ${in_port_params} ${chain_in_params} ${in_params} --state RELATED ${additional}

      fi

  elif [[ ${type} == "client" ]]; then
    if strcontains "${option}" 'ACCEPT ENABLE ALLOW' --ignorecase; then

      # Allow FTP connections on port 21 incoming
      iptables_wrapper ACCEPT --proto tcp --port-to 21 ${chain_in_params} ${in_params} --state ESTABLISHED ${additional}
      # Allow FTP port 20 for active connections incoming
      iptables_wrapper ACCEPT --proto tcp --port-to 20 ${chain_in_params} ${in_params} --state ESTABLISHED,RELATED ${additional}
      # Finally allow FTP passive inbound traffic incoming
      iptables_wrapper ACCEPT --proto tcp ${in_port_params} ${chain_in_params} ${in_params} --state ESTABLISHED ${additional}

      # Allow FTP connections on port 21 outgoing
      iptables_wrapper ACCEPT --proto tcp --port-from 21 ${chain_out_params} ${out_params} --state NEW,ESTABLISHED ${additional}
      # Allow FTP port 20 for active connections outgoing
      iptables_wrapper ACCEPT --proto tcp --port-from 20 ${chain_out_params} ${out_params} --state ESTABLISHED ${additional}
      # Finally allow FTP passive inbound traffic outgoing
      iptables_wrapper ACCEPT --proto tcp ${out_port_params} ${chain_out_params} ${out_params} --state ESTABLISHED,RELATED ${additional}

    elif strcontains "${option}" 'DROP DISABLE BLOCK' --ignorecase; then

      # Allow FTP connections on port 21 outgoing
      iptables_wrapper DROP --proto tcp --port-from 21 ${chain_out_params} ${out_params} --state NEW ${additional}
      # Allow FTP port 20 for active connections incoming
      iptables_wrapper DROP --proto tcp --port-to 20 ${chain_in_params} ${in_params} --state RELATED ${additional}
      # Finally allow FTP passive inbound traffic outgoing
      iptables_wrapper DROP --proto tcp ${out_port_params} ${chain_out_params} ${out_params} --state RELATED ${additional}

    fi
  fi

  if [ -n "${chain}" ]; then
    iptables_wrapper "${chain_in}" --proto tcp --chain INPUT --port-to 20,21 ${in_params}
    iptables_wrapper "${chain_in}" --proto tcp --chain INPUT ${in_port_params} ${in_params}
    iptables_wrapper "${chain_out}" --proto tcp --chain OUTPUT --port-from 20,21 ${out_params}
    iptables_wrapper "${chain_out}" --proto tcp --chain OUTPUT ${out_port_params} ${out_params}
  fi


  return 0
}

function pkg_handler()
{
  local -A tcp_map
  tcp_map=(
    [name]='badpkg'
    [desc]='Invalid package:package state is Invalidate'
    [server]='handle_package_server'
  )

  encode_handler tcp_map
}

function synflood_handler()
{
  local -A synflood_map
  synflood_map=(
    [name]='synflood'
    [desc]='Syn-flood attack:it limit syn package speed rate.'
    [server]='handle_synflood_server'
  )

  encode_handler synflood_map
}

function stealscan_handler()
{
  local -A stealscan_map
  stealscan_map=(
    [name]='stealscan'
    [desc]='Stealth scan:tcp package with unnormal flags'
    [server]='handle_stealscan_server'
  )

  encode_handler stealscan_map
}

function broadcast_handler()
{
  local -A broadcast_map
  broadcast_map=(
    [name]='broadcast'
    [desc]='broadcast:all broadcast packages'
    [server]='handle_broadcast_server'
  )

  encode_handler broadcast_map
}

function icmp_handler()
{
  local -A icmp_map
  icmp_map=(
    [name]='icmp'
    [desc]='icmp package'
    [server]='handle_icmp_server_and_client'
    [client]='handle_icmp_server_and_client'
  )

  encode_handler icmp_map
}

function ssh_handler()
{
	local -A ssh_map
	ssh_map=(
    [name]='ssh'
    [desc]='ssh package'
		[port]="${DEFAULT_PORT[SSH]}"
    [protocol]="tcp"
		[server]="handle_ssh_server"
	)
	
	encode_handler ssh_map
}

function web_handler()
{
	local -A http_map
	http_map=(
    [name]='web'
    [desc]='web handler: for http and https package'
    [protocol]="tcp"
		[server]="handle_web_server"
	)
	
	encode_handler http_map
}

function ftp_handler()
{
	local -A ftp_map
	ftp_map=(
    [name]='ftp'
    [desc]='ftp package'
    [protocol]="tcp"
		[server]="handle_ftp_server_and_client"
		[client]="handle_ftp_server_and_client"
	)
	
	encode_handler ftp_map
}

####################################################################################################
# Entry
####################################################################################################


# Use critical environment
# PATH=/sbin:/usr/sbin:/bin:/usr/bin
ATH=/sbin:/bin


# Force root
if [ "$(id -u)" -ne 0 ]; then
  echo_fatal "'${CMD} should run with root"
fi

# Read configuration
info_level=$(iptables_config --read --key info.level)
if [ -n "${info_level}" ]; then
  if valid_info_level "${info_level}"; then
    set_info_level "${info_level}"
  else
    echo_err "Invalid info.level from global config:${info_level}"
    iptables_config --remove --key info.level
  fi
fi



# regist build-in handler
regist_handler WALL-PKG pkg_handler
regist_handler WALL-SYNFLOOD synflood_handler
regist_handler WALL-SCAN stealscan_handler
regist_handler WALL-BROADCAST broadcast_handler
regist_handler ICMP icmp_handler
regist_handler SSH ssh_handler
regist_handler Http web_handler
regist_handler Https web_handler
regist_handler ftp ftp_handler


# Parse sub-command
sub_cmd=$1
shift
if [[ -z ${sub_cmd} ]]; then
  echo_fatal "param error. use '${CMD} --help' to show document"
fi


if strcontains "${sub_cmd}" 'start' --ignorecase; then
  iptables_start $@
elif strcontains "${sub_cmd}" 'clear' --ignorecase; then
  iptables_clear $@
elif strcontains "${sub_cmd}" 'save' --ignorecase; then
  iptables_save $@
elif strcontains "${sub_cmd}" 'default' --ignorecase; then
  iptables_default $@
elif strcontains "${sub_cmd}" 'chain' --ignorecase; then
  iptables_chain $@
elif strcontains "${sub_cmd}" 'filter' --ignorecase; then
  iptables_filter $@
elif strcontains "${sub_cmd}" 'nat' --ignorecase; then
  iptables_nat $@
elif strcontains "${sub_cmd}" 'incoming' --ignorecase; then
  iptables_wall incoming "$@"
elif strcontains "${sub_cmd}" 'outgoing' --ignorecase; then
  iptables_wall outgoing "$@"
elif strcontains "${sub_cmd}" 'server' --ignorecase; then
  iptables_wall server "$@"
elif strcontains "${sub_cmd}" 'client' --ignorecase; then
  iptables_wall client "$@"
elif strcontains "${sub_cmd}" 'list' --ignorecase; then
  iptables_list "$@"
elif strcontains "${sub_cmd}" 'loopback' --ignorecase; then
  iptables_loopback $@
elif strcontains "${sub_cmd}" 'config' --ignorecase; then
  iptables_config $@
elif strcontains "${sub_cmd}" 'handler' --ignorecase; then
  iptables_handler $@
elif strcontains "${sub_cmd}" 'buckup' --ignorecase; then
  iptables_storage buckup $@
elif strcontains "${sub_cmd}" 'restore' --ignorecase; then
  iptables_storage restore $@
elif [[ ${sub_cmd} == "--version" ]] || [[ ${sub_cmd} == '-v' ]]; then
  echo "${CMD} ${VERSION}"
  exit 0
elif [[ ${sub_cmd} == "--help" ]] || [[ ${sub_cmd} == '-h' ]]; then
  usage
  exit 0
else
  echo_fatal "Unknown sub command:'${sub_cmd}'. Use '${CMD} --help' to show document"
fi

