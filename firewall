#!/bin/bash

CMD=$(basename $0)
# LAN='enp0s8'
# WAN='enp0s17'
SYSCFG_PATH='/etc/sysctl.conf'
FILENAME_NAT='iptables'
FILENAME_NAT6='iptables6'

RULE_DIR='/etc/myrule'
CONFIG_FILE='/var/lib/yuxi/firewall.conf'

DEBUG=true
# silent
# error
# debug
INFO_SILENT=0
INFO_FATAL=1
INFO_ERROR=4
INFO_WARNING=5
INFO_NOTICE=7
INFO_INFO=8
INFO_DEBUG=9
INFO_LEVEL=${INFO_ERROR} # default error

#CMD
IPTABLES='/usr/sbin/iptables'
IP6TABLES='/usr/sbin/ip6tables'

IPTABLES_SAVE='/usr/sbin/iptables-save'
IP6TABLES_SAVE='/usr/sbin/ip6tables-save'

IPTABLES_RESTORE='/usr/sbin/iptables-restore'
IP6TABLES_RESTORE='/usr/sbin/ip6tables-restore'

SYSCTL='/usr/sbin/sysctl'


####################################################################################################
# OS-TYPE
####################################################################################################

function os_type()
{
	
	local release=''
	
	if [ -n "${OSTYPE}" ]; then
		if [[ "${OSTYPE}" == "linux-gnu"* ]]; then
			release="linux"
		elif [[ "${OSTYPE}" == "bsd"* ]]; then 
			release="bsd"
		elif [[ "${OSTYPE}" == "freebsd"* ]]; then 
			release="freebsd"
		elif [[ "${OSTYPE}" == "darwin"* ]]; then 
			release="osx"
		elif [[ "${OSTYPE}" == "solaris"* ]]; then 
			release="solaris"
		elif [[ "${OSTYPE}" == "cygwin" ]]; then 
			# POSIX compatibility layer and Linux environment emulation for Windows 
			release="cygwin"
		elif [[ "${OSTYPE}" == "msys" ]]; then 
			# Lightweight shell and GNU utilities compiled for Windows (part of MinGW) 
			release="msys"
		elif [[ "${OSTYPE}" == "win32" ]]; then 
			# I'm not sure this can happen. 
			release="windows"
		else 
			release="unknown"
		fi
	else
		
		# $OSTAYPE not recognized by the older shells (such as Bourne shell).
		# Use `uname` instead
		
		case $(uname | tr '[:upper:]' '[:lower:]') in
			linux*)
				release='linux'
			;;
			freebsd*)
				release='freebsd'
			;;
			darwin*)
				release="osx"
			;;
			SunOS*)
				release="solaris"
			;;
			msys*)
				release="msys"
			;;
			windows*)
				release="windows"
			;;
			*)
				release="unknown"
			;;
		esac
	fi
	

	echo "${release}"
}

function linux_type()
{
    if [ "$(id -u)" -ne 0 ]; then
      echo_fatal "should run with root"
    fi

    local release=
	if [[ "${OSTYPE}" == "linux-gnu"* ]]; then
		if [[ -n $(find /etc -name "redhat-release") ]] || grep </proc/version -q -i "centos"; then
			release="centos"
		elif grep </etc/issue -q -i "debian" && [[ -f "/etc/issue" ]] || grep </etc/issue -q -i "debian" && [[ -f "/proc/version" ]]; then
			release="debian"
		elif grep </etc/issue -q -i "ubuntu" && [[ -f "/etc/issue" ]] || grep </etc/issue -q -i "ubuntu" && [[ -f "/proc/version" ]]; then
			release="ubuntu"
		else
			release="linux"
		fi
	else
	    release="unknown"
	fi

  echo "${release}"
}

####################################################################################################
# configuration
####################################################################################################

function _sed_escape() {
	sed -e 's/[]\/$*.^[]/\\&/g'
}


function has_cfg_haskey()
{

	local file=
	local key=

	while [ $# -gt 0 ]; do
		case $1 in
		--file )
			shift
			file=$1
		;;

		--key )
			shift
			key=$1
		;;

		*)
			echo_fatal "Invalid optional ${1}"
		;;
		esac
		shift
	done


	if [ -z "${key}" ]; then
		echo_fatal 'key is empty'
	fi

	if [ -z "${file}" ]; then
		echo_fatal 'file is empty'
	fi

	
	local fixkey=$(echo "${key}" | _sed_escape)
	test -f "${file}" && grep -Eq "^\s*${fixkey}\s*=\s*.*$" "${file}" 
}

function read_cfg_key()
{

	local file=
	local key=

	while [ $# -gt 0 ]; do
		case $1 in
		--file )
			shift
			file=$1
		;;

		--key )
			shift
			key=$1
		;;

		*)
			echo_fatal "Invalid optional ${1}"
		;;
		esac
		shift
	done

	if [ -z "${key}" ]; then
		echo_fatal 'key is empty'
	fi

	if [ -z "${file}" ]; then
		echo_fatal 'file is empty'
	fi


	local fixkey=$(echo "${key}" | _sed_escape)
	test -f "${file}" && grep -E "^\s*${fixkey}\s*=\s*" "${file}" | sed -e  "s/[[:space:]]*${fixkey}[[:space:]]*=[[:space:]]*//g" | grep -o "[^ ]\+\( \+[^ ]\+\)*"
}

function delete_cfg_key()
{

	local file=
	local key=

	while [ $# -gt 0 ]; do
		case $1 in
		--file )
			shift
			file=$1
		;;

		--key )
			shift
			key=$1
		;;

		*)
			echo_fatal "Invalid optional ${1}"
		;;
		esac
		shift
	done


	if [ -z "${key}" ]; then
		echo_fatal 'key is empty'
	fi

	if [ -z "${file}" ]; then
		echo_fatal 'file is empty'
	fi


	local fixkey=$(echo "${key}" | _sed_escape)
	if [[ $(os_type) == 'osx' ]]; then
		test -f "${file}" && sed -i "" "/^[[:space:]]*${fixkey}[[:space:]]*=.*$/d" "${file}"
	else
		test -f "${file}" && sed -i "/^[[:space:]]*${fixkey}[[:space:]]*=.*$/d" "${file}"
	fi
}

function commentout_cfg_key()
{
    
	local file=
	local key=

	while [ $# -gt 0 ]; do
		case $1 in
		--file )
			shift
			file=$1
		;;

		--key )
			shift
			key=$1
		;;

		*)
			echo_fatal "Invalid optional ${1}"
		;;
		esac
		shift
	done


	if [ -z "${key}" ]; then
		echo_fatal 'key is empty'
	fi

	if [ -z "${file}" ]; then
		echo_fatal 'file is empty'
	fi

	
	local fixkey=$(echo "${key}" | _sed_escape)
	if [[ $(os_type) == 'osx' ]]; then
		test -f "${file}" && sed -i "" "s/^[[:space:]]*\(${fixkey}[[:space:]]*=.*\)$/#\1/g" "${file}"
	else
		test -f "${file}" && sed -i "s/^[[:space:]]*\(${fixkey}[[:space:]]*=.*\)$/#\1/g" "${file}"
	fi
}

function write_cfg_key()
{

	local file=
	local key=
	local val=

	while [ $# -gt 0 ]; do
		case $1 in
		--file )
			shift
			file=$1
    ;;

		--key )
			shift
			key=$1
    ;;

		--val )
			shift
			val=$1
    ;;

    *)
			echo_fatal "Invalid optional ${1}"
    ;;
		esac
		shift
	done


  if [ -z "${key}" ]; then
    echo_fatal 'key is empty'
	fi

	if [ -z "${val}" ]; then
    echo_fatal 'val is empty'
	fi

	if [ -z "${file}" ]; then
		echo_fatal 'file is empty'
	fi


	local fixkey=$(echo "${key}" | _sed_escape)
	if test -f "${file}" &&  grep -Eq "^\s*${fixkey}\s*=\s*${val}\s*$" "${file}"; then # Testfile exist and text 'key = val' exist, do nothing ...
		:
	elif test -f "${file}" && grep -Eq "^\s*#\s*${fixkey}\s*=.*$" "${file}"; then #Test file exist and text '# key = xxx' exist
		if 	grep -Eq "^\s*#\s*${fixkey}\s*=\s*${val}\s*$" "${file}"; then #Test exist '# key = val', remove '#' and format line.
			if [[ $(os_type) == 'osx' ]]; then
				sed -i "" "s/^[[:space:]]*#*[[:space:]]*${fixkey}[[:space:]]*=.*/${fixkey} = ${val}/g" "${file}"
			else
				sed -i "s/^[[:space:]]*#*[[:space:]]*${fixkey}[[:space:]]*=.*/${fixkey} = ${val}/g" "${file}"
			fi
		else # Text '# key=???' exist, append 'key = val' below.
			if [[ $(os_type) == 'osx' ]]; then
			    # 因为sed在OSX上的问题，这里不得不换行!!!
				sed -i "" "/^[[:space:]]*#*[[:space:]]*${fixkey}[[:space:]]*=.*/ a\\
				${fixkey} = ${val}\\
				" "${file}"
			else
				sed -i "/^[[:space:]]*#*[[:space:]]*${fixkey}[[:space:]]*=.*/ a ${fixkey} = ${val}" "${file}"
			fi
		fi
	else
		echo "${key} = ${val}" >> "${file}"
	fi	
}

####################################################################################################
# Other YXLib
####################################################################################################


function yx_str_checkfmt()
{
	local reg=$1
	local str=$2
	
	if [[ -z ${str} ]]; then
		str=''
	fi
	
	if [[ -z ${reg} ]]; then
		reg='^\s*[^\s]+\s*$'
	fi
	
	if ! [[ ${str} =~ ${reg} ]] ; then
		return 1
	fi
	
	return 0
}

function ip_forward_v4()
{
  local option=$1
  shift
  if [ -z ${option} ]; then
    echo_fatal 'iptables_default need at least one params [DROP , ACCEPT]'
  else
    if [[ ${option} == 'enable' ]] || [[ ${option} == 'accept' ]] || [[ ${option} == '1' ]]; then
      option='1'
    else
      option='0'
    fi
  fi

  # 使用sed更改sysctl.conf中的ip_forward值
  #:echo_cmd
  echo_warn 'Set ipv4.ip_forward = 1 ...'
  echo_info "sed -i \"s/^#\? *net.ipv4.ip_forward.*/net.ipv4.ip_forward = ${option}/g\" \"${SYSCFG_PATH}\""
  sed -i "s/^#\? *net.ipv4.ip_forward.*/net.ipv4.ip_forward = ${option}/g" "${SYSCFG_PATH}"
 
  #如果需要，立即应用更改
  #:echo_cmd
  echo_warn 'Make system configure enable...'
  echo_info "${SYSCTL} -p > /dev/null"
  "${SYSCTL}" -p > /dev/null

  local result=0
  if grep -Eq "^ *net.ipv4.ip_forward" "${SYSCFG_PATH}"; then
    result=$(grep -E "^ *net.ipv4.ip_forward" "${SYSCFG_PATH}" | sed -e 's/^[^#=]*= *//g' )
  else
    result=0
  fi

  if [[ ${result} == 1 ]]; then
    return 0
  else
    return 1
  fi
}

####################################################################################################
# Logger
####################################################################################################

function set_info_level()
{
  local info_level=$1
  if [ -n "${info_level}" ]; then

    if yx_str_checkfmt '^([0-9])+$' "${info_level}"; then
      INFO_LEVEL=${info_level}
    else
      if [[ ${info_level} == 'silent' ]] || [[ ${info_level} == 'Silent' ]] || [[ ${info_level} == 'SILENT' ]]; then
        INFO_LEVEL=${INFO_SILENT}
      elif [[ ${info_level} == 'fatal' ]] || [[ ${info_level} == 'Fatal' ]] || [[ ${info_level} == 'FATAL' ]]; then
        INFO_LEVEL=${INFO_FATAL}
      elif [[ ${info_level} == 'error' ]] || [[ ${info_level} == 'Error' ]] || [[ ${info_level} == 'ERROR' ]]; then
        INFO_LEVEL=${INFO_ERROR}
      elif [[ ${info_level} == 'warning' ]] || [[ ${info_level} == 'Warning' ]] || [[ ${info_level} == 'WARNING' ]]; then
        INFO_LEVEL=${INFO_WARNING}
      elif [[ ${info_level} == 'notice' ]] || [[ ${info_level} == 'Notice' ]] || [[ ${info_level} == 'NOTICE' ]]; then
        INFO_LEVEL=${INFO_NOTICE}
      elif [[ ${info_level} == 'info' ]] || [[ ${info_level} == 'Info' ]] || [[ ${info_level} == 'INFO' ]]; then
        INFO_LEVEL=${INFO_INFO}
      elif [[ ${info_level} == 'debug' ]] || [[ ${info_level} == 'Debug' ]] || [[ ${info_level} == 'DEBUG' ]]; then
        INFO_LEVEL=${INFO_DEBUG}
      else
        echo_fatal "Unknown info level:${info_level}"
      fi
    fi # end of 'if yx_str_checkfmt '^([0-9])+$' '

  fi # end of 'if [ -n ${info_level} ]'
}


function echo_debug()
{
  if (( "${INFO_LEVEL}" < "${INFO_DEBUG}" )); then
    return
  fi

  local str=
	if (( $# == 0 )) ; then
		read -r -t 5 -d $'\0' str
#		num=`cat < /dev/stdin`
	else
		str="$*"
	fi

  (>&1 echo "${str}")
}

# info
function echo_info()
{
  if (( "${INFO_LEVEL}" < "${INFO_INFO}" )); then
    return
  fi

  local str=
	if (( $# == 0 )) ; then
		read -r -t 5 -d $'\0' str
#		num=`cat < /dev/stdin`
	else
		str="$*"
	fi

  local green=$(tput setaf 2);
  local reset=$(tput sgr0);
  (>&1 echo "${green}${str}${reset}")
}

 # notification   
function echo_noti()
{
  if (( "${INFO_LEVEL}" < "${INFO_NOTICE}" )); then
    return
  fi

  local str=
	if (( $# == 0 )) ; then
		read -r -t 5 -d $'\0' str
#		num=`cat < /dev/stdin`
	else
		str="$*"
	fi

  local blue=$(tput setaf 4);
  local reset=$(tput sgr0);
  
  (>&1 echo "${blue}${str}${reset}")
}

function echo_warn()
{
  if (( "${INFO_LEVEL}" < "${INFO_WARNING}" )); then
    return
  fi

  local str=
	if (( $# == 0 )) ; then
		read -r -t 5 -d $'\0' str
#		num=`cat < /dev/stdin`
	else
		str="$*"
	fi

  local yellow=$(tput setaf 3);
  local reset=$(tput sgr0);

  (>&2 echo "${yellow}${str}${reset}")
}

function echo_err()
{
  if (( "${INFO_LEVEL}" < "${INFO_ERROR}" )); then
    return
  fi

  local str=
	if (( $# == 0 )) ; then
		read -r -t 5 -d $'\0' str
#		num=`cat < /dev/stdin`
	else
		str="$*"
	fi

  local magenta=$(tput setaf 5);
  local reset=$(tput sgr0);

  (>&2 echo "${magenta}${str}${reset}")
}

function echo_fatal()
{
  if (( "${INFO_LEVEL}" < "${INFO_FATAL}" )); then
    exit 1
  fi

  local str=
	if (( $# == 0 )) ; then
		read -r -t 5 -d $'\0' str
#		num=`cat < /dev/stdin`
	else
		str="$*"
	fi

  local red=$(tput setaf 1);
  local reset=$(tput sgr0);
  
  (>&2 echo "${red}Fatal:${str}${reset}");
  exit 1;
}

# Can not handle 'pipe' and 'output redirect'
# Use '#:echo_cmd' mark all not handle code place
function echo_cmd()
{
  echo_info "$@"
  $@
}

function analysis_cmd()
{
  echo "##############################################################################"
  echo "Run command:\"$@\""
  echo "------------------------------------------------------------------------------"
  local start=$(date +%s)
	$@
	local exit_code=$?
  echo "------------------------------------------------------------------------------"
	echo "took $(($(date +%s)-${start})) seconds. exited with ${exit_code}"
  echo "##############################################################################"
	return $exit_code
}


####################################################################################################
# usage
####################################################################################################


function usage() {
cat <<EOF
  usage: ${CMD} <sub-command> <optional>
  For IPV4 package filtering and nat

  usage: ${CMD} <--help|-h> 
  For this help information.

  usage: ${CMD} <sub-command> <--help|-h>
  For detail information for sub-command

  The following sub-command are allowed:
  start:    Start the firewall service
  clear:    Clear all settings
  save:     Save firewall change
  default:  Set default police to filter table
  filter:   Filter IPV4 package
  nat:      SNAT or DNAT IPV4 package

  The following sub-command for fast usage
  port:     Filter package with specific ports.
  loopback: Filter package on loopback.

  The following sub-command for protocol fast usage
  ping:     Fast command for icmp ping
  ssh:      Fast command for ssh
  http:     Fast command for http
  https:    Fast command for https
  web:      Fast command for web (all http, https and others...)
EOF
}

function usage_clear() {
cat <<EOF
  usage: ${CMD} clear [--info-level xxx]
  Clear all settings.

  The followint option are availiable:
  --info-level     Command output level.
                   The specific level can be one of 'silent', 'fatal', 'error', 'warning', 'notice, 'info', 'debug'.
                   It can be a number equal or great than 0.


  Other options
  Use '${CMD} --help' show all help information

EOF
}

function usage_start() {
cat <<EOF
  usage: ${CMD} start [--info-level xxx]
  Start the firewall service

  The followint option are availiable:
  --info-level     Command output level.
                   The specific level can be one of 'silent', 'fatal', 'error', 'warning', 'notice, 'info', 'debug'.
                   It can be a number equal or great than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function usage_save() {
cat <<EOF
  usage: ${CMD} save [option] 
  Save the firewall change

  The followint option are availiable:
  --log-input      Add INPUT log at the end of INPUT chain. --log-input 'prefix:'
  --log-output     Add OUTPUT log at the end of OUTPUT chain. --log-output 'prefix:'
  --log-forward    Add FORWARD log at the end of FORWARD chain. --log-forward 'prefix:'

  --info-level     Command output level.
                   The specific level can be one of 'silent', 'fatal', 'error', 'warning', 'notice, 'info', 'debug'.
                   It can be a number equal or great than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function usage_default() {
cat <<EOF
  usage: ${CMD} default <accept|drop> [options]
  Set default police to filter table. 
  NOTE: This command will always change all IPv6 policy to 'DROP'

  usage: ${CMD} default <--list|-l> [options]
  Show default police to specific filter table

  The following options are allowed:
  --input    add input chain to target
  --output   add output chain to target
  --forward  add forward chain to target
  --all      add all chain to target

  --list     show default police to specific filter table

  --info-level     Command output level.
                   The specific level can be one of 'silent', 'fatal', 'error', 'warning', 'notice, 'info', 'debug'.
                   It can be a number equal or great than 0.

  -h|--help     show this help information

  Other options
  Use '${CMD} --help' show all help information

EOF
}

function usage_filter()
{
  cat <<EOF
  usage: ${CMD} filter <accept|drop> [options]
  For IPV4 package filtering

  usage: ${CMD} filter --list
  Show filter rule information

  The following options are allowed:

  --list           List filter rule information.

  --interface      Name of an interface via which a package was received.
  --not-interface  Same as '--interface' but sense is inverted.

  --proto          The protocol of the rule or of the packet to check. The specified protocol can be one of 'tcp'
                   , 'udp', 'udplite', 'icmp', 'esp', 'ah', 'sctp', 'mh' or the special keyward 'all', or it can 
                   be a numeric value, representing one of these protocols or a different one.
  --inflag         Aditional parms of '--proto'. (Currently, only support --icmp-type for icmp protocol)
  --outflag        Aditional parms of '--proto'. (Currently, only support --icmp-type for icmp protocol)

  --in-port        Indicate ports for incomming connection. (use ',' for muti-port num. port1,port2,...)
  --out-port       Indicate ports for outgoing connection. (use ',' for muti-port num. port1,port2,...)

  --ip-from        Indicate ip-address from incomming connection. (support ip format: 192.168.0.1 | 192.168.0.1/24 | 192.168.0.1-192.168.0.99)
  --ip-notfrom     Same as '--ip-from' but sense is inverted.
  --ip-to          Indicate ip-address from outgoing connection (support ip format: 192.168.0.1 | 192.168.0.1/24 | 192.168.0.1-192.168.0.99)
  --ip-notto       Same as 'ip-to' but sense is inverted.

  --mac            Indicate a mac-address. (e.g. 11:22:33:44:55:66)
  --notmac         Same as '--mac' but sense is inverted.

  --limit rate     Maximum average matching rate: specified as a number, with an optional (/second|/minute|/hour|day). the default is 3/hour
  --notlimit       Same as '--limit rate' but sense is inverted
  --limit-burst    Maximum initial number of packets to match: this number gets recharged by one every time the limit specified above is not reached,
                   up to this number; the default is 5.
  
  --log            Record filter information.

  --info-level     Command output level.
                   The specific level can be one of 'silent', 'fatal', 'error', 'warning', 'notice, 'info', 'debug'.
                   It can be a number equal or great than 0.

  --help|-h        Show this help information

  Other options
  Use '${CMD} --help' show all help information
EOF
}

function usage_nat() {
cat <<EOF
  usage: ${CMD} nat <--snat|dnat> --from-inter xxx --to-inter xx [--log]
  For IPV4 package NAT(Network Address Translation).

  usage: ${CMD} nat --list
  Show nat rule information.

  --list        List nat rule information.
  --snat        Command work as SNAT(Source Network Address Translatioon)
  --dnat        Command work as DNAT(Destination Network Address Translation)

  --from-inter  Name of an interface which the source network durning the address translation.
  --to-inter    Name of an interface which the destination network during the address translatioon.

  --log         Record log on forward request

  --info-level     Command output level.
                   The specific level can be one of 'silent', 'fatal', 'error', 'warning', 'notice, 'info', 'debug'.
                   It can be a number equal or great than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}


function usage_port() {
cat <<EOF
  usage: ${CMD} port <ACCEPT|DROP> <--service|--client> <--port xxx,xxx,xxx>
  Fast command for indicate ports number on fireware. It is '${CMD} filter''s wrapper command.

  The followint options are allowed:
  --service     Command work on incomming connection.
  --client      Command work on outgoing connection.
  --port        Indicate the port number.

  --info-level     Command output level.
                   The specific level can be one of 'silent', 'fatal', 'error', 'warning', 'notice, 'info', 'debug'.
                   It can be a number equal or great than 0.

  Others:
  All '${CMD} filter' optional are support. Use '${CMD} filter --help' for more information.
  
  NOTE: In this command, you should ignore '--in-port' and '--out-port' optional.
        These two optional perform the same as '--port'.

  Other options
  Use '${CMD} --help' show all help information

EOF
}


function usage_loopback() {
cat <<EOF
  usage: ${CMD} loopback <ACCEPT|DROP> [-infolevel xxx]
  Fast command for loopback interface. It is '${CMD} filter''s wrapper command.


  --info-level    Command output level.
                  The specific level can be one of 'silent', 'fatal', 'error', 'warning', 'notice, 'info', 'debug'.
                  It can be a number equal or great than 0.


  Use '${CMD} filter --help' for more information.

  Other options
  Use '${CMD} --help' show all help information

EOF
}


function usage_ping() {
cat <<EOF
  usage: ${CMD} ping <ACCEPT|DROP> <--service|--client> <--port xxx,xxx,xxx>
  Fast command for icmp ping. It is '${CMD} filter''s wrapper command.

  The followint options are allowed:
  --service     For incomming ping request package.
  --client      For outgoing ping request package.

  --info-level  Command output level.
                The specific level can be one of 'silent', 'fatal', 'error', 'warning', 'notice, 'info', 'debug'.
                It can be a number equal or great than 0.

  Others:
  All '${CMD} filter' optional are support. Use '${CMD} filter --help' for more information.
  
  NOTE: In this command, you should ignore '--proto' optional.

  Other options
  Use '${CMD} --help' show all help information

EOF
}


function usage_ssh() {
cat <<EOF
  usage: ${CMD} ssh <ACCEPT|DROP> <--service|--client> <optional>
  Fast command for ssh. It is '${CMD} filter''s wrapper command.

  The followint options are allowed:
  --service     For ssh service request package.
  --client      For ssh client request package.
  --port        Indicate the port number. default port number is 22.

  --info-level  Command output level.
                The specific level can be one of 'silent', 'fatal', 'error', 'warning', 'notice, 'info', 'debug'.
                It can be a number equal or great than 0.

  Others:
  All '${CMD} filter' optional are support. Use '${CMD} filter --help' for more information.
  
  NOTE: In this command, you should ignore '--in-port' and '--out-port' optional.
        These two optional perform the same as '--port'.
  NOTE: In this command, you should ignore '--proto' optional.

  Other options
  Use '${CMD} --help' show all help information

EOF
}


function usage_http() {
cat <<EOF
  usage: ${CMD} http <ACCEPT|DROP> <--service|--client> <optional>
  Fast command for http. It is '${CMD} filter''s wrapper command.

  The followint options are allowed:
  --service     For ssh service request package.
  --client      For ssh client request package.
  --port        Indicate the port number. default port number is 80.

  --info-level  Command output level.
                The specific level can be one of 'silent', 'fatal', 'error', 'warning', 'notice, 'info', 'debug'.
                It can be a number equal or great than 0.

  Others:
  All '${CMD} filter' optional are support. Use '${CMD} filter --help' for more information.
  
  NOTE: In this command, you should ignore '--in-port' and '--out-port' optional.
        These two optional perform the same as '--port'.
  NOTE: In this command, you should ignore '--proto' optional.

  Other options
  Use '${CMD} --help' show all help information

EOF
}



function usage_https() {
cat <<EOF
  usage: ${CMD} https <ACCEPT|DROP> <--service|--client> <optional>
  Fast command for https. It is '${CMD} filter''s wrapper command.

  The followint options are allowed:
  --service     For ssh service request package.
  --client      For ssh client request package.
  --port        Indicate the port number. default port number is 443.

  --info-level  Command output level.
                The specific level can be one of 'silent', 'fatal', 'error', 'warning', 'notice, 'info', 'debug'.
                It can be a number equal or great than 0.

  Others:
  All '${CMD} filter' optional are support. Use '${CMD} filter --help' for more information.
  
  NOTE: In this command, you should ignore '--in-port' and '--out-port' optional.
        These two optional perform the same as '--port'.
  NOTE: In this command, you should ignore '--proto' optional.

  Other options
  Use '${CMD} --help' show all help information

EOF
}


function usage_web() {
cat <<EOF
  usage: ${CMD} web <ACCEPT|DROP> <--service|--client> <optional>
  Fast command for web. It is '${CMD} filter''s wrapper command.

  The followint options are allowed:
  --service     For ssh service request package.
  --client      For ssh client request package.
  --port        Indicate the port number. default port number is 80,443.

  --info-level  Command output level.
                The specific level can be one of 'silent', 'fatal', 'error', 'warning', 'notice, 'info', 'debug'.
                It can be a number equal or great than 0.

  Others:
  All '${CMD} filter' optional are support. Use '${CMD} filter --help' for more information.
  
  NOTE: In this command, you should ignore '--in-port' and '--out-port' optional.
        These two optional perform the same as '--port'.
  NOTE: In this command, you should ignore '--proto' optional.

  Other options
  Use '${CMD} --help' show all help information

EOF
}


function usage_config() {
cat <<EOF
  usage: ${CMD} config <--read|--write|--list|--help> <optional>
  'Show' or 'Change' ${CMD} config property

  usage: ${CMD} config --help
  Display this help information


  The follow operation:
  --read        Read specific config with 'key'
  --write       Write config item with 'key' and 'val'
  --remove      Remove a config item with 'key'
  --list        List all config items
  --help        Show this help information
  
  The following options are allowed:
  --key         Name of a config property
  --val         Value of a config property

  The following additional options are allowed:
  --info-level  Command output level.
              The specific level can be one of 'silent', 'fatal', 'error', 'warning', 'notice, 'info', 'debug'.
              It can be a number equal or great than 0.

  Other options
  Use '${CMD} --help' show all help information

EOF
}


####################################################################################################
# iptables
####################################################################################################

function iptables_config()
{
    local option=
    local key=
    local val=

    local show_help=false
    local info_level=

    while [ $# -gt 0 ]; do
		case $1 in

      --read )
        option='read'
      ;;

      --write )
        option='write'
      ;;

      --remove )
        option='remove'
      ;;

      --list )
        option='list'
      ;;

      --key )
        shift
        key=$1
      ;;

      --val )
        shift
        val=$1
      ;;

      --info-level )
        shift
        info_level=$1
			;;

			--help )
				show_help=true
			;;

      *)
        echo_fatal "Invalid optional ${1}"
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_config
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    mkdir -p "$(dirname ${CONFIG_FILE})"

    if [[ "${option}" == 'read' ]]; then

      if [[ -z ${key} ]]; then
        echo_fatal "${CMD} --read config must provide key value, using --key"
      fi

      if [ -r "${CONFIG_FILE}" ]; then
        read_cfg_key --file "${CONFIG_FILE}" --key "${key}"
      fi

    elif [[ "${option}" == 'write' ]]; then

      if [[ -z ${key} ]]; then
        echo_fatal "${CMD} --write must provide key property, using --key"
      fi

      if [[ -z ${val} ]]; then
        echo_fatal "${CMD} --write must provide value property, using --val"
      fi

      write_cfg_key --file "${CONFIG_FILE}" --key "${key}" --val "${val}"
    elif [[ "${option}" == 'remove' ]]; then

      if [[ -z ${key} ]]; then
        echo_fatal "${CMD} --read config must provide key value, using --key"
      fi

      if [ -w "${CONFIG_FILE}" ]; then
        delete_cfg_key --file "${CONFIG_FILE}" --key "${key}"
      fi

    elif [[ "${option}" == 'list' ]]; then

      if [ -r "${CONFIG_FILE}" ]; then
        cat "${CONFIG_FILE}"
      fi

    else
      echo_fatal "${CMD} config must provide one optional --read, --write or list "
    fi

  fi

}

function iptables_start()
{
  local show_help=false
  local info_level=

  while [ $# -gt 0 ]; do
		case $1 in

      --info-level )
        shift
        info_level=$1
			;;

			--help )
				show_help=true
			;;

			*)
        echo_fatal "Invalid optional ${1}, try '-h' or '--help' to show more information"
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_start
    exit 0
  else
    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    local system=$(linux_type)
    if [[ ${system} == "centos" || ${system} == "debian" ]]; then
      echo_warn 'Start iptables service...'
      echo_cmd "start iptables.service"
      echo_cmd "enable iptables.service"
    elif [[ ${system} == "ubuntu" ]]; then
      :
    else
      :
    fi

  fi

}

function iptables_save()
{
  
  local show_help=false
  local info_level=

  local log_input=false
  local log_input_prefix=
  local log_output=false
  local log_output_prefix=
  local log_forward=false
  local log_forward_prefix=

  while [ $# -gt 0 ]; do
		case $1 in

      --log-input )
        shift
        log_input=true
				log_input_prefix=$1
			;;

      --log-output )
        shift
				log_output=true
        log_output_prefix=$1
			;;

      --log-forward )
        shift
				log_forward=true
        log_forward_prefix=$1
			;;

      --info-level )
        shift
        info_level=$1
      ;;

			--help )
				show_help=$1
			;;

			*)
        echo_fatal "Invalid optional ${1}, try '-h' or '--help' to show more information"
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_save
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    input_optional=$(iptables_default --list --input)

    if ${log_input}; then

      if [ -z "${log_input_prefix}" ]; then
        log_input_prefix="${CMD}-Drop-Input:"
      fi

      # iptables -N LAST_LOGGING
      # iptables -A INPUT -j LAST_LOGGING
      #iptables -A LAST_LOGGING -m limit --limit 2/min -j LOG --log-prefix "${log_input_prefix}" --log-level 7
      # iptables -A LAST_LOGGING -j LOG --log-prefix "${log_input_prefix}" --log-level 7
      # iptables -A LAST_LOGGING -j DROP

      echo_warn 'Add INPUT DROP Log ...'
      echo_cmd "${IPTABLES} -A INPUT -j LOG --log-prefix ${log_input_prefix} --log-level 7"
    fi

    if ${log_output}; then

      if [ -z "${log_output_prefix}" ]; then
        log_output_prefix="${CMD}-Drop-Output:"
      fi

      echo_warn 'Add OUTPUT DROP Log ...'
      echo_cmd "${IPTABLES} -A OUTPUT -j LOG --log-prefix ${log_output_prefix} --log-level 7"
    fi


    if ${log_forward}; then

      if [ -z "${log_forward_prefix}" ]; then
        log_forward_prefix="${CMD}-Drop-Forward:"
      fi

      echo_warn 'Add FORWARD DROP Log ...'
      echo_cmd "${IPTABLES} -A FORWARD -j LOG --log-prefix ${log_forward_prefix} --log-level 7"
    fi


    local system=$(linux_type)
    if [[ ${system} == "centos" || ${system} == "debian" ]]; then
      echo_warn 'Save changes...'
      echo_cmd "service iptables save"

      echo_warn 'Restart iptables services...'
      echo_cmd "service iptables stop"
      echo_cmd "service iptables start"
    elif [[ ${system} == "ubuntu" ]]; then

      if [ ! -d  "${RULE_DIR}" ]; then
          echo_err "DIR ${RULE_DIR} not exist, try create one"
          echo_cmd "mkdir -p ${RULE_DIR}"
          if [ ! -d  "${RULE_DIR}" ]; then
            echo_fatal "mkdir ${RULE_DIR} ..."
          fi
      fi

      # save current config
      RULE_FILE="${RULE_DIR}/${FILENAME_NAT}".rules
      local script_file_v4="/etc/network/if-pre-up.d/${FILENAME_NAT}"

      RULE6_FILE="${RULE_DIR}/${FILENAME_NAT6}".rules
      local script_file_v6="/etc/network/if-pre-up.d/${FILENAME_NAT6}"

      # Create iptables rule file ...
      echo_warn "Create iptables rule file ..."
      echo_cmd "${IPTABLES_SAVE} --file ${RULE_FILE}"
      echo_cmd "${IP6TABLES_SAVE} --file ${RULE6_FILE}"
      
      # Create launch script ...
      echo_warn "Create launch script ..."
      echo -e "#!/bin/bash\n${IPTABLES_RESTORE} < ${RULE_FILE}" | tee ${script_file_v4} | echo_info
      echo -e "#!/bin/bash\n${IP6TABLES_RESTORE} < ${RULE6_FILE}" | tee ${script_file_v6} | echo_info
      
    else
      :
    fi

  fi


  # log


  # local option=$1
  # if [ -n "${option}" ]; then
  #   if [[ ${option} == '--help' ]] || [[ ${option} == '-h' ]]; then
  #     usage_save
  #   else
  #     echo_fatal "unknown optional \"${option}\""
  #   fi
  # else

  # fi


}

function iptables_clear()
{
  local show_help=false
  local info_level=

  while [ $# -gt 0 ]; do
		case $1 in

      --info-level )
        shift
        info_level=$1
        ;;

      --help )
        show_help=true
      ;;

      *)
        echo_fatal "Invalid optional ${1}, try '-h' or '--help' to show more information"
        exit 1
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_clear
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    echo_warn 'Clear all rules...'

    echo_cmd "${IPTABLES} -F"
    echo_cmd "${IPTABLES} -X"
    echo_cmd "${IPTABLES} -Z"
    echo_cmd "${IPTABLES} -t nat -F"
    echo_cmd "${IPTABLES} -t nat -X"
    echo_cmd "${IPTABLES} -t nat -Z"

    echo_cmd "${IP6TABLES} -F"
    echo_cmd "${IP6TABLES} -X"
    echo_cmd "${IP6TABLES} -Z"
    echo_cmd "${IP6TABLES} -t nat -F"
    echo_cmd "${IP6TABLES} -t nat -X"
    echo_cmd "${IP6TABLES} -t nat -Z"
  fi

}

function iptables_default()
{
  local opt_input=false
  local opt_output=false
  local opt_forward=false

  local show=false

  local show_help=false
  local info_level=

  local option=$1
  if [[ ${option} == 'enable' ]] || [[ ${option} == 'accept' ]] || [[ ${option} == 'ACCEPT' ]] ; then
    option="ACCEPT"
    shift
  elif [[ ${option} == 'disable' ]] || [[ ${option} == 'drop' ]] || [[ ${option} == 'DROP' ]]; then
    option="DROP"
    shift
  else
    option=
  fi

  # shift
  # if [ -z ${option} ]; then
  #   echo_fatal 'iptables_default need at least one params [DROP , ACCEPT]'
  # fi

  # if [[ ${option} == 'accept' ]] || [[ ${option} == 'ACCEPT' ]] ; then
  #   option="ACCEPT"
  #   shift
  # elif [[ ${option} == 'drop' ]] || [[ ${option} == 'DROP' ]]; then
  #   option="DROP"
  #   shift
  # elif [[ ${option} == '--help' ]] || [[ ${option} == '-h' ]]; then
  #   usage_default
  #   exit 1
  # # else
  # #   echo_fatal "unknown optional \"${option}\""
  # fi

  while [ $# -gt 0 ]; do
		case $1 in
			--input )
        opt_input=true
			;;

			--output )
        opt_output=true
			;;

			--forward )
        opt_forward=true
      ;;

			--all )
        opt_input=true
        opt_output=true
        opt_forward=true
			;;

			--list )
        show=true
      ;;

      --info-level )
        shift
        info_level=$1
      ;;


			-h | --help )
        show_help=true
			;;

			*)
        echo_fatal "Invalid optional ${1}, try '-h' or '--help' to show more information"
				exit 1
				;;
		esac
		shift
	done


  if ${show_help}; then
    usage_default
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi


    if ! ${show}; then
    
      if [ -z ${option} ]; then
        echo_fatal 'iptables default need at least one params [DROP , ACCEPT]'
      fi

      echo_warn 'Set default policy...'

      if ${opt_input}; then
        echo_cmd "${IPTABLES} -P INPUT ${option}"
      fi

      if ${opt_output}; then
        echo_cmd "${IPTABLES} -P OUTPUT ${option}"
      fi

      if ${opt_forward}; then
        echo_cmd "${IPTABLES} -P FORWARD ${option}"
      fi

      # always drop ipv6
      echo_cmd "${IP6TABLES} -P INPUT DROP"
      echo_cmd "${IP6TABLES} -P OUTPUT DROP"
      echo_cmd "${IP6TABLES} -P FORWARD DROP"
    else

      if ${opt_input}; then
        #:echo_cmd
        "${IPTABLES}" -L INPUT -nv | head --lines 1 | awk '{print $4}' | grep -o "[^ ]\+\( \+[^ ]\+\)*"
      fi

      if ${opt_output}; then
        #:echo_cmd
        "${IPTABLES}" -L OUTPUT -nv | head --lines 1 | awk '{print $4}' | grep -o "[^ ]\+\( \+[^ ]\+\)*"
      fi

      if ${opt_forward}; then
        #:echo_cmd
        "${IPTABLES}" -L FORWARD -nv | head --lines 1 | awk '{print $4}' | grep -o "[^ ]\+\( \+[^ ]\+\)*"
      fi
    fi
  fi





}

function iptables_filter()
{

  local interface=
  local not_interface=

  local inports=
  local outports=

  local protocol=
  local inflag=
  local outflag=

  local limit=
  local not_limit=
  local limit_burst=

  local ip_from=
  local ip_not_from=
  local ip_to=
  local ip_not_to=

  local mac=
  local not_mac=

  local log=false
  local log_prefix=$1

  local info_level=
  local show=false

  local show_help=false

  local option=$1
  if [[ ${option} == 'enable' ]] || [[ ${option} == 'accept' ]] || [[ ${option} == 'ACCEPT' ]] ; then
    option="ACCEPT"
    shift
  elif [[ ${option} == 'disable' ]] || [[ ${option} == 'drop' ]] || [[ ${option} == 'DROP' ]]; then
    option="DROP"
    shift
  else
    option=
  fi


	while [ $# -gt 0 ]; do
		case $1 in
			--interface )
				shift
				interface=$1
			;;

			--not-interface )
				shift
				not_interface=$1
			;;

			--in-flag )
				shift
				inflag=$1
			;;

			--out-flag )
				shift
				outflag=$1
			;;

			--in-port )
				shift
				inports=$1
			;;

			--out-port )
				shift
				outports=$1
			;;

			--proto )
				shift
				protocol=$1
			;;

      --limit )
				shift
        limit=$1
      ;;

      --notlimit )
				shift
        not_limit=$1
      ;;

      --limit-burst )
				shift
        limit_burst=$1
      ;;

      --ip-from )
				shift
        ip_from=$1
      ;;

      --ip-notfrom )
				shift
        ip_not_from=$1
      ;;

      --ip-to )
				shift
        ip_to=$1
      ;;

      --ip-notto )
				shift
        ip_not_to=$1
      ;;

      --mac )
				shift
        mac=$1
      ;;

      --notmac )
				shift
        not_mac=$1
      ;;

      --list )
        show=true
      ;;

      --log )
        shift
	      log=true
        log_prefix=$1
			;;

      --info-level )
        shift
        info_level=$1
      ;;

      --help )
        show_help=true
      ;;

			*)
        echo_fatal "Invalid optional ${1}, try '-h' or '--help' to show more information"
				;;
		esac
		shift
	done


  if ${show_help}; then
    usage_filter
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    if ${show}; then
      echo_cmd "iptables -nvL"
      exit 0
    else

      if [ -z ${option} ]; then
        echo_fatal 'iptables filter need at least one params [DROP , ACCEPT]'
      fi

      # interface
      local output_interface_param=''
      local input_interface_param=''
      if [[ -n ${interface} ]]; then
        output_interface_param=" -o ${interface}"
        input_interface_param=" -i ${interface}"
      elif [[ -n ${not_interface} ]]; then 
        output_interface_param=" ! -o ${not_interface}"
        input_interface_param=" ! -i ${not_interface}"
      fi

      # protocol
      local protocol_params=''
      if [[ -n ${protocol} ]]; then
        protocol_params=" -p ${protocol}"
      fi

      # protocol flag
      local inflag_params=''
      local outflag_params=''
      if [[ ${protocol} == "icmp" ]]; then
        if [[ -n ${inflag} ]]; then
          inflag_params=" --icmp-type ${inflag}"
        fi
        if [[ -n ${outflag} ]]; then
          outflag_params=" --icmp-type ${outflag}"
        fi
      else
        if [[ -n ${inflag} ]]; then
          echo_fatal "unknown --in-flag ${inflag} for protocol ${protocol}"
        fi
        if [[ -n ${outflag} ]]; then
          echo_fatal "unknown --out-flag ${outflag} for protocol ${protocol}"
        fi
      fi

      # Test -m limit params
      # --limit_freq [6/second | 6/min | xx/hour 6/day]
      local limit_params=''
      if [[ -n ${limit_burst} ]] || [[ -n ${limit} ]] || [[ -n ${not_limit} ]]; then
        limit_params=' -m limit'

        # --limit
        if [[ -n ${limit} ]]; then
          if yx_str_checkfmt '^([0-9])+/(s|min|second|minute|day)$' "${limit}"; then
            limit_params="${limit_params} --limit ${limit}"
          else
            echo_fatal "\"${limit}\" is not a valid params for --freq"
          fi
        elif [[ -n ${not_limit} ]]; then
          if yx_str_checkfmt '^([0-9])+/(s|min|second|minute|day)$' "${not_limit}"; then
            limit_params="${limit_params} ! --limit ${not_limit}"
          else
            echo_fatal "\"${not_limit}\" is not a valid params for --freq"
          fi
        fi
        
        # --limit-burst
        if [[ -n ${limit_burst} ]]; then
          if yx_str_checkfmt '^([0-9])+$' "${limit_burst}"; then
            limit_params="${limit_params} --limit-burst ${limit_burst}"
          else
            echo_fatal "\"${limit_burst}\" is not a valid params for --limit"
          fi
        fi

      fi


      #indicate from ip-address or net-segment
      local ip_from_params=''
      if [[ -n ${ip_from} ]]; then
          if yx_str_checkfmt '^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}(/[0-3]?[0-9])?$' "${ip_from}"; then
            ip_from_params=" -s ${ip_from}"
          elif yx_str_checkfmt '^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}-([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}$' "${ip_from}"; then
            ip_from_params=" -m iprange --src-range ${ip_from}"
          else
            echo_fatal "\"${ip_from}\" is not a valid ip-address or net-setment"
          fi
      elif [[ -n ${ip_not_from} ]]; then
          if yx_str_checkfmt '^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}(/[0-3]?[0-9])?$' "${ip_not_from}"; then
            ip_from_params=" !-s ${ip_not_from}"
          elif yx_str_checkfmt '^([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}-([0-2]?[0-9]{1,2}\.){3}[0-2]?[0-9]{1,2}$' "${ip_not_from}"; then
            ip_from_params=" -m iprange ! --src-range ${ip_not_from}"
          else
            echo_fatal "\"${ip_not_from}\" is not a valid ip-address or net-setment"
          fi
      fi

      #indicate target ip-address or net-segment
      local ip_to_params=''
      if [[ -n ${ip_to} ]]; then
          if yx_str_checkfmt '(\d{1,3}\.){3}\d{1,3}(/\d{1,3})?' "${ip_to}"; then
            ip_to_params=" -d ${ip_to}"
          elif yx_str_checkfmt '(\d{1,3}\.){3}\d{1,3}-(\d{1,3}\.){3}\d{1,3}' "${ip_to}"; then
            ip_from_params=" -m iprange --dst-range ${ip_to}"
          else
            echo_fatal "\"${ip_to}\" is not a valid ip-address or net-setment"
          fi
      elif [[ -n ${ip_not_to} ]]; then
          if yx_str_checkfmt '(\d{1,3}\.){3}\d{1,3}(/\d{1,3})?' "${ip_not_to}"; then
            ip_to_params=" ! -d ${ip_not_to}"
          elif yx_str_checkfmt '(\d{1,3}\.){3}\d{1,3}-(\d{1,3}\.){3}\d{1,3}' "${ip_not_to}"; then
            ip_from_params=" -m iprange ! --dst-range ${ip_not_to}"
          else
            echo_fatal "\"${ip_not_to}\" is not a valid ip-address or net-setment"
          fi
      fi

      local mac_params=''
      if [[ -n ${mac} ]]; then
        mac_params=" -m mac --mac-source ${mac}"
      elif [[ -n ${not_mac} ]]; then
        mac_params=" -m mac ! --mac-source ${not_mac}"
      fi



      if [[ -z ${inports} ]]  &&  [[ -z ${outports} ]]; then
          if ${log}; then
            if [[ -z ${log_prefix} ]]; then
              log_prefix="${CMD}-Filter:"
            fi
            
            # Add filter log...
            echo_warn 'Add filter log...'
            echo_cmd "${IPTABLES} -A INPUT${input_interface_param}${protocol_params}${inflag_params}${mac_params}${ip_from_params}${ip_to_params}${limit_params} -j LOG --log-prefix ${log_prefix} --log-level 4"
            echo_cmd "${IPTABLES} -A OUTPUT${output_interface_param}${protocol_params}${outflag_params}${mac_params}${ip_from_params}${ip_to_params}${limit_params} -j LOG --log-prefix ${log_prefix} --log-level 4"
          fi
          # Add filter rule...
          echo_warn 'Add filter rule...'
          echo_cmd "${IPTABLES} -A INPUT${input_interface_param}${protocol_params}${inflag_params}${mac_params}${ip_from_params}${ip_to_params}${limit_params} -j ${option}"
          echo_cmd "${IPTABLES} -A OUTPUT${output_interface_param}${protocol_params}${outflag_params}${mac_params}${ip_from_params}${ip_to_params}${limit_params} -j ${option}"
      else

        if [[ -n ${inports} ]]; then
          if ${log}; then
            if [[ -z ${log_prefix} ]]; then
              log_prefix="${CMD}-Incomming:"
            fi
            # Add filter incoming log...
            echo_warn 'Add filter incoming log...'
            echo_cmd "${IPTABLES} -A INPUT${input_interface_param}${protocol_params}${inflag_params}${mac_params} -m multiport${limit_params} --dports ${inports}${ip_from_params}${ip_to_params} -m state --state NEW,ESTABLISHED -j LOG --log-prefix ${log_prefix} --log-level 4"
          fi

          # Add filter incoming rule...
          echo_warn 'Add filter incoming rule...'
          echo_cmd "${IPTABLES} -A INPUT${input_interface_param}${protocol_params}${inflag_params}${mac_params} -m multiport${limit_params} --dports ${inports}${ip_from_params}${ip_to_params} -m state --state NEW,ESTABLISHED -j ${option}"
          echo_cmd "${IPTABLES} -A OUTPUT${output_interface_param}${protocol_params}${outflag_params}${mac_params} -m multiport${limit_params} --sports ${inports}${ip_from_params}${ip_to_params} -m state --state ESTABLISHED -j ${option}"
        fi

        if [[ -n ${outports} ]]; then
          if ${log}; then
            if [[ -z ${log_prefix} ]]; then
              log_prefix="${CMD}-Outgoing:"
            fi
            # Add filter outgoing log...
            echo_warn 'Add filter outgoing log...'
            echo_cmd "${IPTABLES} -A OUTPUT${output_interface_param}${protocol_params}${inflag_params}${mac_params} -m multiport${limit_params} --dports ${outports}${ip_from_params}${ip_to_params} -m state --state NEW,ESTABLISHED -j LOG --log-prefix ${log_prefix} --log-level 4"
          fi

          # Add filter outgoing rule...
          echo_warn 'Add filter outgoing rule...'
          echo_cmd "${IPTABLES} -A OUTPUT${output_interface_param}${protocol_params}${inflag_params}${mac_params} -m multiport${limit_params} --dports ${outports}${ip_from_params}${ip_to_params} -m state --state NEW,ESTABLISHED -j ${option}"
          echo_cmd "${IPTABLES} -A INPUT${input_interface_param}${protocol_params}${outflag_params}${mac_params} -m multiport${limit_params} --sports ${outports}${ip_from_params}${ip_to_params} -m state --state ESTABLISHED -j ${option}"
        fi

      fi # end of [[ -z ${inports} ]]  &&  [[ -z ${outports} ]]

    fi # end of if ${show};

  fi # end of if ${show_help}

}


function iptables_nat()
{

  local show=false
  local snat=false
  local dnat=false
  
  # lan
  local from_inter=
  # wan
  local to_inter=
  local log=false
  local log_prefix=

  local info_level=


	while [ $# -gt 0 ]; do
		case $1 in

			--snat )
				snat=true
			;;

			--dnat )
				dnat=true
			;;

			--list )
				show=true
			;;

			--from-inter )
				shift
				from_inter=$1
			;;

			--to-inter )
				shift
				to_inter=$1
			;;

			--log )
        shift
				log=true
        log_prefix=$1
			;;

      --info-level )
        shift
        info_level=$1
      ;;


			*)
        usage_nat
				exit
				;;
		esac
		shift
	done


  if ${show}; then
    echo_cmd "iptables -t nat -nvL"
    exit 0
  elif ${snat}; then

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi


    if ${dnat}; then
      echo_fatal "Can not set both '--snat' and '--dnat' in one command"
    fi

    if [[ -z ${from_inter} ]]; then
      echo_fatal "Invalid --from-inter params"
    fi

    if [[ -z ${to_inter} ]]; then
      echo_fatal "Invalid --to-inter params"
    fi

    # set net.ipv4.ip_forward=1
    #echo "IP forwarding has been set to '1'"
    if ! ip_forward_v4 enable; then
      echo_fatal "failed to change net.ipv4.ip_forward item to '1'"
    fi

    # 允许初始网络包转发
    if ${log}; then
      if [[ -z ${log_prefix} ]]; then
        log_prefix="${CMD}-Forward:"
      fi
      
      # Add forwarding log
      echo_warn 'Add forwarding log...'
      echo_cmd "${IPTABLES} -A FORWARD -o ${to_inter} -i ${from_inter} -m conntrack --ctstate NEW -j LOG --log-prefix ${log_prefix} --log-level 4"
    fi

    # Add forwarding rule
    echo_warn 'Add forwarding rule...'
    echo_cmd "${IPTABLES} -A FORWARD -o ${to_inter} -i ${from_inter} -m conntrack --ctstate NEW -j ACCEPT"
    # 允许已经建立链接的网络包转发
    #sudo iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
    echo_cmd "${IPTABLES} -A FORWARD -o ${to_inter} -i ${from_inter} -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT"
    echo_cmd "${IPTABLES} -A FORWARD -o ${from_inter} -i ${to_inter} -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT"

    # 设置SNAT
    # add SNAT rule
    echo_warn 'add SNAT rule...'
    #iptables -t nat -A POSTROUTING -s 192.168.56.0/24 -j SNAT --to-source 10.0.2.15
    echo_cmd "${IPTABLES} -t nat -A POSTROUTING -o ${to_inter} -j MASQUERADE" # 这个记得之前应该好使啊????!!!!

    # 设置一个dnat, 强制DNS使用1.1.1.1
    #这个不需要设置
    #如果设置，客户端DNS的IP好像必须设置成一样的
    #sudo iptables -t nat -A PREROUTING -p udp --dport 53 -j DNAT --to 1.1.1.1

  elif ${dnat};then

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    echo_fatal 'not implement !!!'
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi
    echo_fatal "One of '--snat' or '--dnat' must be set."
  fi

}

function iptables_port()
{
  local ports=
  local default_ports=
  local must_proto=
  local service=false
  local client=false
  local additional=''

  local show_help=false
  local info_level=

  # ignore params
  local protocol=

  local option=$1
  if [[ ${option} == 'enable' ]] || [[ ${option} == 'accept' ]] || [[ ${option} == 'ACCEPT' ]] ; then
    option="ACCEPT"
    shift
  elif [[ ${option} == 'disable' ]] || [[ ${option} == 'drop' ]] || [[ ${option} == 'DROP' ]]; then
    option="DROP"
    shift
  else
    option=
  fi


	while [ $# -gt 0 ]; do
		case $1 in
			--service )
				service=true
			;;

			--client )
        client=true
			;;

			--default-port )
				shift
				default_ports=$1
			;;

			--must-proto )
				shift
				must_proto=$1
			;;

			--port )
				shift
				ports=$1
			;;

			--in-port )
				shift
				ports=$1
			;;

			--out-port )
				shift
				ports=$1
			;;

			--proto )
				shift
				protocol=$1
			;;

      --info-level )
        shift
        info_level=$1
      ;;

      --help )
          show_help=true
      ;;


			*)
        additional="${additional} $1"
      ;;
		esac
		shift
	done

  if ${show_help}; then
    usage_port
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    if [ -z ${option} ]; then
      echo_fatal 'iptables port need at least one params [DROP , ACCEPT]'
    fi

    if [[ -n ${protocol} ]]; then
      if [[ -n ${must_proto} ]] && [[ ${protocol} != ${must_proto} ]]; then
          echo_fatal "${CMD} port can not allow \"${protocol}\" protocol"
      fi
    else
      protocol=${must_proto}
      if [[ -z ${protocol} ]]; then
          echo_fatal "${CMD} port must provide \"--proto\" or \"--must-proto\" params"
      fi
    fi


    if [[ -z ${ports} ]]; then
      ports=${default_ports}
      if [[ -z ${ports} ]]; then
        echo_fatal "${CMP} port must provide --ports params"
      fi
    fi


    if ${service}; then
      iptables_filter ${option} --proto ${protocol} --in-port ${ports} ${additional}
    elif ${client}; then
      iptables_filter ${option} --proto ${protocol} --out-port ${ports} ${additional}
    else
      echo_fatal "${CMD} port must at least indicate one of --service and --client optional"
    fi
  fi

}

function iptables_loopback()
{

  local option=$1
  if [[ ${option} == 'enable' ]] || [[ ${option} == 'accept' ]] || [[ ${option} == 'ACCEPT' ]] ; then
    option="ACCEPT"
    shift
  elif [[ ${option} == 'disable' ]] || [[ ${option} == 'drop' ]] || [[ ${option} == 'DROP' ]]; then
    option="DROP"
    shift
  else
    option=
  fi


  local additional=''

  # ignore params
  local interface=
  local not_interface=

  local show_help=false
  local info_level=

	while [ $# -gt 0 ]; do
		case $1 in

      --interface )
				shift
				interface=$1
			;;

			--not-interface )
				shift
				not_interface=$1
			;;

      --info-level )
        shift
        info_level=$1
        ;;

      --help )
        show_help=true
      ;;


			*)
        additional="${additional} $1"
      ;;
		esac
		shift
	done

  if ${show_help}; then
    usage_loopback
    exit 0
  else
     
    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    if [ -z ${option} ]; then
      echo_fatal 'iptables loopback need at least one params [DROP , ACCEPT]'
    fi

    if [[ -n ${interface} ]]  &&  [[ ${interface} != 'icmp' ]]; then
      echo_fatal "${CMD} loopback can not allow \"${interface}\" interface"
    fi

    if [[ -n ${not_interface} ]]; then
      echo_fatal "${CMD} loopback can not support --not-interface params"
    fi

    # iptables -A INPUT -i lo -j ACCEPT
    # iptables -A OUTPUT -o lo -j ACCEPT
    iptables_filter ${option} --interface lo
  fi

}

function iptables_ping()
{

  local service=false
  local client=false
  local additional=''

  local show_help=false
  local info_level=

  # ignore params
  local protocol=


  local option=$1
  if [[ ${option} == 'enable' ]] || [[ ${option} == 'accept' ]] || [[ ${option} == 'ACCEPT' ]] ; then
    option="ACCEPT"
    shift
  elif [[ ${option} == 'disable' ]] || [[ ${option} == 'drop' ]] || [[ ${option} == 'DROP' ]]; then
    option="DROP"
    shift
  else
    option=
  fi


	while [ $# -gt 0 ]; do
		case $1 in
			--service )
				service=true
			;;

			--client )
        client=true
			;;

			--proto )
				shift
				protocol=$1
			;;

      --info-level )
        shift
        info_level=$1
        ;;

      --help )
        show_help=true
      ;;

			*)
        additional="${additional} $1"
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_ping
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi


    if [ -z ${option} ]; then
      echo_fatal 'iptables XXX need at least one params [DROP , ACCEPT]'
    fi

    ## Others...
    if [[ -n ${protocol} ]]  &&  [[ ${protocol} != 'icmp' ]]; then
      echo_fatal "${CMD} pint can not allow \"${protocol}\" protocol"
    fi

    if ${service}; then
      iptables_filter ${option} --proto icmp --in-flag echo-request --out-flag echo-reply ${additional}
    elif ${client}; then
      iptables_filter ${option} --proto icmp --out-flag echo-request --in-flag echo-reply ${additional}
    else
      echo_fatal "${CMD} ping must at least indicate one of --service and --client optional"
    fi
  fi

}


function iptables_ssh()
{

  local additional=''
  local show_help=false
  local info_level=

  local option=$1
  if [[ ${option} == 'enable' ]] || [[ ${option} == 'accept' ]] || [[ ${option} == 'ACCEPT' ]] ; then
    option="ACCEPT"
    shift
  elif [[ ${option} == 'disable' ]] || [[ ${option} == 'drop' ]] || [[ ${option} == 'DROP' ]]; then
    option="DROP"
    shift
  else
    option=
  fi

  while [ $# -gt 0 ]; do
		case $1 in

      --info-level )
        shift
        info_level=$1
      ;;

      --help )
        show_help=true
      ;;

      *)
        additional="${additional} $1"
      ;;
		esac
		shift
	done

  if ${show_help}; then
    usage_ssh
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi


    if [ -z ${option} ]; then
      echo_fatal 'iptables ssh need at least one params [DROP , ACCEPT]'
    fi

    iptables_port "${option}" --must-proto tcp --default-port 22 ${additional}
  fi

}


function iptables_http()
{

  local additional=''
  local show_help=false
  local info_level=

  local option=$1
  if [[ ${option} == 'enable' ]] || [[ ${option} == 'accept' ]] || [[ ${option} == 'ACCEPT' ]] ; then
    option="ACCEPT"
    shift
  elif [[ ${option} == 'disable' ]] || [[ ${option} == 'drop' ]] || [[ ${option} == 'DROP' ]]; then
    option="DROP"
    shift
  else
    option=
  fi


  while [ $# -gt 0 ]; do
		case $1 in

      --info-level )
        shift
        info_level=$1
      ;;

      --help )
        show_help=true
      ;;

      *)
        additional="${additional} $1"
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_http
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    if [ -z ${option} ]; then
      echo_fatal 'iptables http need at least one params [DROP , ACCEPT]'
    fi

    iptables_port "${option}" --must-proto tcp --default-port 80 ${additional}
  fi

}


function iptables_https()
{
  
  local additional=''
  local show_help=false
  local info_level=

  local option=$1
  if [[ ${option} == 'enable' ]] || [[ ${option} == 'accept' ]] || [[ ${option} == 'ACCEPT' ]] ; then
    option="ACCEPT"
    shift
  elif [[ ${option} == 'disable' ]] || [[ ${option} == 'drop' ]] || [[ ${option} == 'DROP' ]]; then
    option="DROP"
    shift
  else
    option=
  fi


  while [ $# -gt 0 ]; do
		case $1 in

      --info-level )
        shift
        info_level=$1
      ;;

      --help )
        show_help=true
      ;;

      *)
        additional="${additional} $1"
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_https
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    if [ -z ${option} ]; then
      echo_fatal 'iptables https need at least one params [DROP , ACCEPT]'
    fi

    iptables_port "${option}" --must-proto tcp --default-port 443 ${additional}
  fi

}


function iptables_web()
{

  local additional=''
  local show_help=false
  local info_level=

  local option=$1
  if [[ ${option} == 'enable' ]] || [[ ${option} == 'accept' ]] || [[ ${option} == 'ACCEPT' ]] ; then
    option="ACCEPT"
    shift
  elif [[ ${option} == 'disable' ]] || [[ ${option} == 'drop' ]] || [[ ${option} == 'DROP' ]]; then
    option="DROP"
    shift
  else
    option=
  fi


  while [ $# -gt 0 ]; do
		case $1 in

      --info-level )
        shift
        info_level=$1
      ;;

      --help )
        show_help=true
      ;;

      *)
        additional="${additional} $1"
      ;;
		esac
		shift
	done


  if ${show_help}; then
    usage_https
    exit 0
  else

    if [ -n "${info_level}" ]; then
      set_info_level "${info_level}"
    fi

    if [ -z ${option} ]; then
      echo_fatal 'iptables web need at least one params [DROP , ACCEPT]'
    fi

    iptables_port "${option}" --must-proto tcp --default-port 443,80 ${additional}
  fi

}




if [ "$(id -u)" -ne 0 ]; then
  echo_fatal "'${CMD} should run with root"
fi

info_level=$(iptables_config --read --key info.level)
if [ -n "${info_level}" ]; then
  set_info_level "${info_level}"
fi


sub_cmd=$1
shift
if [[ -z ${sub_cmd} ]]; then
  echo_fatal "param error. use '${CMD} --help' to show document"
fi


if [[ ${sub_cmd} == "start" ]]; then
  iptables_start $@
elif [[ ${sub_cmd} == "clear" ]]; then
  iptables_clear $@
elif [[ ${sub_cmd} == "save" ]]; then
  iptables_save $@
elif [[ ${sub_cmd} == "default" ]]; then
  iptables_default $@
elif [[ ${sub_cmd} == "filter" ]]; then
  iptables_filter $@
elif [[ ${sub_cmd} == "nat" ]]; then
  iptables_nat $@
elif [[ ${sub_cmd} == "port" ]]; then
  iptables_port $@
elif [[ ${sub_cmd} == "loopback" ]]; then
  iptables_loopback $@
elif [[ ${sub_cmd} == "ping" ]]; then
  iptables_ping $@
elif [[ ${sub_cmd} == "ssh" ]]; then
  iptables_ssh $@
elif [[ ${sub_cmd} == "http" ]]; then
  iptables_http $@
elif [[ ${sub_cmd} == "https" ]]; then
  iptables_https $@
elif [[ ${sub_cmd} == "web" ]]; then
  iptables_web $@
elif [[ ${sub_cmd} == "config" ]]; then
  iptables_config $@
elif [[ ${sub_cmd} == "--help" ]] || [[ ${sub_cmd} == '-h' ]]; then
  usage
  exit 0
else
  echo_fatal "Unknown sub command:'${sub_cmd}'. Use '${CMD} --help' to show document"
fi
